{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Android und Android Studio Auf den folgenden Seiten finden Sie Informationen und Aufgaben zur Entwicklung von Android Apps mit Java und Android Studio. Die Informationen stammen an vielen Stellen aus englischsprachigen Prim\u00e4rquellen, deshalb ist ein Gro\u00dfteil der Lehrunterlagen in englischer Sprache verfasst. Kapitel\u00fcbersicht Java Kapitel 1: Collections und Generics Kapitel 2: Serialisierung und Input- / OutputStreams Kapitel 3: Singleton Kapitel 4: Serialisation von Singleton-Klassen Android Kapitel 1: Grundlagen zu Android und Android Studio Kapitel 2: Activities und Intents Kapitel 3: Handler Kapitel 4: JavaScript Object Notation (JSON) Kapitel 5: Daten-Speicher und Persistenz Kapitel 6: App Bar und Toolbar Kapitel 7: RecyclerView Kapitel 8a: AsyncTask Kapitel 8b: Threads und Thread Kommunikation ( neu ) Diese Unterlagen wurden mit MkDocs , Markdown und Visual Studio Code erstellt und mit dem individuell angepassten Material Theme for MkDocs gerendert.","title":"Index"},{"location":"#android-und-android-studio","text":"Auf den folgenden Seiten finden Sie Informationen und Aufgaben zur Entwicklung von Android Apps mit Java und Android Studio. Die Informationen stammen an vielen Stellen aus englischsprachigen Prim\u00e4rquellen, deshalb ist ein Gro\u00dfteil der Lehrunterlagen in englischer Sprache verfasst.","title":"Android und Android Studio"},{"location":"#kapitelubersicht","text":"","title":"Kapitel\u00fcbersicht"},{"location":"#java","text":"Kapitel 1: Collections und Generics Kapitel 2: Serialisierung und Input- / OutputStreams Kapitel 3: Singleton Kapitel 4: Serialisation von Singleton-Klassen","title":"Java"},{"location":"#android","text":"Kapitel 1: Grundlagen zu Android und Android Studio Kapitel 2: Activities und Intents Kapitel 3: Handler Kapitel 4: JavaScript Object Notation (JSON) Kapitel 5: Daten-Speicher und Persistenz Kapitel 6: App Bar und Toolbar Kapitel 7: RecyclerView Kapitel 8a: AsyncTask Kapitel 8b: Threads und Thread Kommunikation ( neu ) Diese Unterlagen wurden mit MkDocs , Markdown und Visual Studio Code erstellt und mit dem individuell angepassten Material Theme for MkDocs gerendert.","title":"Android"},{"location":"actionbar/","text":"Android App Bar (aka Action Bar) Abstract Lernziele Sie kennen die technischen Grundlagen der Android Action Bar Sie k\u00f6nnen eine Action Bar in ihre Applikation integrieren Sie verstehen wie sie Actions definieren und der Action Bar hinzuf\u00fcgen Note Note: The app bar should be implemented using the Android Toolbar to make it available for a wide range of devices. According to the Android developer guidelines, the appcompat Toolbar has the best compatibility support. Note Support Library has been superceded by Android Jetpack With the introduction of Android Jetpack and AndroidX, the support libraries are migrated into Android Jetpack for applications using API Level 28 (Android 9) and above. So if you plan to implement your application for Android Version > 8.0, you could use Android Jetpack instead of the support libaries (earlier versions still need to make use of the support libraries as outlined in this documentation). Source: https://developer.android.com/topic/libraries/support-library/setup Introduction The app bar , also known as the action bar , is one of the most important design elements in your app\u2019s activities, because it provides a visual structure and interactive elements that are familiar to users. Using the app bar makes your app consistent with other Android apps , allowing users to quickly understand how to operate your app and have a great experience. The key functions of the app bar are as follows: A dedicated space for giving your app an identity and indicating the user\u2019s location in the app. Access to important actions in a predictable way, such as search. Support for navigation and view switching (with tabs or drop-down lists). This lecture describes how to use the v7 appcompat support library\u2019s Toolbar widget as an app bar. Note Note: There are other ways to implement an app bar\u2014for example, some themes set up an ActionBar as an app bar by default\u2014but using the appcompat Toolbar makes it easy to set up an app bar that works on the widest range of devices , and also gives you room to customize your app bar later on as your app develops. Choosing the App Bar Implementation In its most basic form, the action bar displays the title for the activity on one side and an overflow menu on the other. Even in this simple form, the app bar provides useful information to the users, and helps to give Android apps a consistent look and feel. An app bar with the app title and an overflow menu Beginning with Android 3.0 (API level 11), all activities that use the default theme have an ActionBar as an app bar. However, app bar features have gradually been added to the native ActionBar over various Android releases. As a result, the native ActionBar behaves differently depending on what version of the Android system a device may be using. By contrast, the most recent features are added to the support library\u2019s version of Toolbar , and they are available on any device that can use the support library. For this reason, it is recommended to use the support library\u2019s Toolbar class to implement activities\u2019 app bars . Using the support library\u2019s toolbar helps ensure that an app will have consistent behavior across the widest range of devices. For example, the Toolbar widget provides a material design experience on devices running Android 2.1 (API level 7) or later, but the native action bar doesn\u2019t support material design unless the device is running Android 5.0 (API level 21) or later. Adding a Toolbar to an Activity These steps describe how to set up a Toolbar as an activity\u2019s app bar: Set the necessary Support Libraries Add the v7 appcompat support library to your project, as described in Support Library Setup . In order to use a Support Library, you must modify the application\u2019s project\u2019s classpath dependencies within the development environment. This procedure must be performed for each Support Library that should be used. To add a Support Library to your application project, include Google\u2019s Maven repository in your top-level build.gradle file. 1 2 3 4 5 6 7 8 9 10 11 12 allprojects { repositories { google () // If you're using a version of Gradle lower than 4.1, you must // instead use: // // maven { // url 'https://maven.google.com' // } } } Then, add the support library to the dependencies section: 1 2 3 4 dependencies { ... implementation \"com.android.support:support-core-utils:27.1.1\" } Warning Note #1: The compile command in the dependencies section is deprecated by the end of 2018. Use implementation instead. Warning Note #2: Make sure that the :support-core-utils version number matches that of the :appcompat-v7 version number, otherwise runtime errors might occur. The following excerpt from the build.gradle (Module:app) file uses version 26.1.0 : 1 2 3 4 5 6 7 8 9 dependencies { implementation 'com.android.support:support-core-utils:26.1.0' implementation fileTree ( dir: 'libs' , include: [ '*.jar' ]) implementation 'com.android.support:appcompat-v7:26.1.0' implementation 'com.android.support.constraint:constraint-layout:1.1.1' testImplementation 'junit:junit:4.12' androidTestImplementation 'com.android.support.test:runner:1.0.2' androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2' } Extend AppCompatActivity Make sure the activity class extends AppCompatActivity , as illustrated below: 1 2 3 public class MyActivity extends AppCompatActivity { // ... } Note Note: You need to make this change for every activity in your app that uses a Toolbar as an app bar. Set the NoActionBar Theme In the app manifest , set the <application> element to use one of appcompat\u2019s NoActionBar themes. Using one of these themes prevents the app from using the native ActionBar class to provide the app bar. For example: 1 2 3 <application android:theme= \"@style/Theme.AppCompat.Light.NoActionBar\" /> Set the Toolbar\u2019s Layout Add a Toolbar to the activity\u2019s layout. For example, the following layout code adds a Toolbar and gives it the appearance of floating above the activity: 1 2 3 4 5 6 7 8 <android.support.v7.widget.Toolbar android:id= \"@+id/my_toolbar\" android:layout_width= \"match_parent\" android:layout_height= \"?attr/actionBarSize\" android:background= \"?attr/colorPrimary\" android:elevation= \"4dp\" android:theme= \"@style/ThemeOverlay.AppCompat.ActionBar\" app:popupTheme= \"@style/ThemeOverlay.AppCompat.Light\" /> Note Note: The Material Design specification recommends that app bars should have an elevation of 4 dp . Position the toolbar at the top of the activity\u2019s layout, since you are using it as an app bar. Call setSupportActionBar() In the activity\u2019s onCreate() method, call the activity\u2019s setSupportActionBar() method, and pass the activity\u2019s toolbar. This method sets the toolbar as the app bar for the activity. For example: 1 2 3 4 5 6 7 @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_my ); Toolbar myToolbar = ( Toolbar ) findViewById ( R . id . my_toolbar ); setSupportActionBar ( myToolbar ); } Make sure that you import the correct Toolbar library, as illustrated below; otherwise the setSupportActionBar() method won\u2019t work. 1 import android.support.v7.widget.Toolbar ; Your app now has a basic action bar. By default, the action bar contains just the name of the app and an overflow menu. The options menu initially contains just the Settings item. You can add more actions to the action bar and the overflow menu, as described in the next Section \u2192 Adding and Handling Actions . Note Hint: Use App Bar Utility Methods Once you set the toolbar as an activity\u2019s app bar, you have access to the various utility methods provided by the v7 appcompat support library\u2019s ActionBar class. This approach lets you do a number of useful things, like hide and show the app bar. To use the ActionBar utility methods , call the activity\u2019s getSupportActionBar() method. This method returns a reference to an appcompat ActionBar object. Once you have that reference, you can call any of the ActionBar methods to adjust the app bar . For example, to hide the app bar, call ActionBar.hide() . Defining and Handling Actions The app bar allows you to add buttons for user actions . This feature lets you put the most important actions for the current context right at the top of the app. For example, a photo browsing app might show share and create album buttons at the top when the user is looking at their photo roll; when the user looks at an individual photo, the app might show crop and filter buttons. Space in the app bar is limited . If an app declares more actions than can fit in the app bar, the app bar send the excess actions to an overflow menu . The app can also specify that an action should always be shown in the overflow menu , instead of being displayed on the app bar. An app bar with a single action button and an overflow menu. Defining Action Buttons All action buttons and other items available in the action overflow are defined in an XML menu resource (\u2192 see https://developer.android.com/guide/topics/resources/menu-resource.html ). To add actions to the action bar, create a new XML file in your project\u2019s res/menu/ directory. The menu can be accessed (e.g. by the MenuInflater class) using R.menu.{name_of_your_menu_xml_file}.xml . Add an <item> element for each item you want to include in the action bar, as shown in the following code example of a menu XML file: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 <menu xmlns:android= \"http://schemas.android.com/apk/res/android\" > <!-- \"Mark Favorite\", should appear as action button if possible --> <item android:id= \"@+id/action_favorite\" android:icon= \"@drawable/ic_favorite_black_48dp\" android:title= \"@string/action_favorite\" app:showAsAction= \"ifRoom\" /> <!-- Settings, should always be in the overflow --> <item android:id= \"@+id/action_settings\" android:title= \"@string/action_settings\" app:showAsAction= \"never\" /> </menu> The app:showAsAction attribute specifies whether the action should be shown as a button on the app bar. If you set app:showAsAction=\"ifRoom\" (as in the example code\u2019s favorite action), the action is displayed as a button if there is room in the app bar for it; if there is not enough room, excess actions are sent to the overflow menu . If you set app:showAsAction=\"never\" (as in the example code\u2019s settings action), the action is always listed in the overflow menu , not displayed in the app bar. The system uses the action\u2019s icon as the action button, if the action is displayed in the app bar. You can find many useful icons on the Material Icons page. Setting Actions on the Toolbar Warning Attention: This step is ommitted in the app bar\u2019s official google developer documents! Actions should be included in the options menu , which is part of the Toolbar if the application is developed for Android 3.0 (API level 11) and higher . By default, the system places all items in the action overflow , which the user can reveal with the action overflow icon on the right side of the app bar (or by pressing the device Menu button, if available). To enable quick access to important actions, you can promote a few items to appear in the app bar by adding android:showAsAction=\"ifRoom\" to the corresponding <item> elements (see Figure 3). The Google Play Movies app, showing a search button and the action overflow button. Note Hint: You can declare items for the options menu from either your Activity subclass or a Fragment subclass. If both your activity and fragment(s) declare items for the options menu, they are combined in the UI. The activity\u2019s items appear first, followed by those of each fragment in the order in which each fragment is added to the activity. If necessary, you can re-order the menu items with the android:orderInCategory attribute in each <item> you need to move. To specify the options menu for an activity, override onCreateOptionsMenu() (fragments provide their own onCreateOptionsMenu() callback). In this method, you can inflate your menu resource (defined in XML) into the Menu provided in the callback. For example: 1 2 3 4 5 6 @Override public boolean onCreateOptionsMenu ( Menu menu ) { MenuInflater inflater = getMenuInflater (); inflater . inflate ( R . menu . action_items , menu ); return true ; } You can also add menu items using add() and retrieve items with findItem() to revise their properties with MenuItem APIs. If you\u2019ve developed your application for Android 2.3.x and lower , the system calls onCreateOptionsMenu() to create the options menu when the user opens the menu for the first time. If you\u2019ve developed for Android 3.0 and higher , the system calls onCreateOptionsMenu() when starting the activity , in order to show items to the app bar . Respond to Actions When the user selects one of the app bar items, the system calls the activity\u2019s onOptionsItemSelected() callback method, and passes a MenuItem object to indicate which item was clicked. In your implementation of onOptionsItemSelected() , call the MenuItem.getItemId() method to determine which item was pressed. The ID returned matches the value you declared in the corresponding <item> element\u2019s android:id attribute. For example, the following code checks to see which action the user selected. If the method does not recognize the user\u2019s action, it invokes the superclass method: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Override public boolean onOptionsItemSelected ( MenuItem item ) { switch ( item . getItemId ()) { case R . id . action_settings : // User chose the \"Settings\" item, show the app settings UI... return true ; case R . id . action_favorite : // User chose the \"Favorite\" action, mark the current item // as a favorite... return true ; default: // If we got here, the user's action was not recognized. // Invoke the superclass to handle it. return super . onOptionsItemSelected ( item ); } } Adding an Up Action An app should make it easy for users to find their way back to the app\u2019s main screen. One simple way to do this is to provide an Up button on the app bar for all activities except the main one. When the user selects the Up button, the app navigates to the parent activity. This section shows you how to add an Up button to an activity by declaring the activity\u2019s parent in the manifest, and enabling the app bar\u2019s Up button. Declaring a Parent Activity To support the up functionality in an activity, you need to declare the activity\u2019s parent . This is done in the app manifest , by setting an android:parentActivityName attribute. Note Note: The android:parentActivityName attribute was introduced in Android 4.1 (API level 16). To support devices with older versions of Android, define a <meta-data> name-value pair, where the name is \"android.support.PARENT_ACTIVITY\" and the value is the name of the parent activity. For example, suppose an app has a main activity named MainActivity and a single child activity. The following manifest code declares both activities, and specifies the parent/child relationship: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 <application ... > ... <!-- The main/home activity (it has no parent activity) --> <activity android:name= \"com.example.myfirstapp.MainActivity\" ... > ... </activity> <!-- A child of the main activity --> <activity android:name= \"com.example.myfirstapp.MyChildActivity\" android:label= \"@string/title_activity_child\" android:parentActivityName= \"com.example.myfirstapp.MainActivity\" > <!-- Parent activity meta-data to support 4.0 and lower --> <meta-data android:name= \"android.support.PARENT_ACTIVITY\" android:value= \"com.example.myfirstapp.MainActivity\" /> </activity> </application> Enable the Up Button To enable the Up button for an activity that has a parent activity, call the app bar\u2019s setDisplayHomeAsUpEnabled() method. Typically, this would be done when the activity is created. For example, the following onCreate() method sets a Toolbar as the app bar for MyChildActivity , then enables that app bar\u2019s Up button: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_my_child ); // my_child_toolbar is defined in the layout file Toolbar myChildToolbar = ( Toolbar ) findViewById ( R . id . my_child_toolbar ); setSupportActionBar ( myChildToolbar ); // Get a support ActionBar corresponding to this toolbar ActionBar ab = getSupportActionBar (); // Enable the Up button ab . setDisplayHomeAsUpEnabled ( true ); } There is no need to catch the up action in the activity\u2019s onOptionsItemSelected() method. Instead, that method should call its superclass, as shown in Respond to Actions. The superclass method responds to the Up selection by navigating to the parent activity, as specified in the app manifest. Action Views and Action Providers Action Views and Action Providers are advanced topics and will not be covered in this lecture. However, more information can be found on the official android developer pages https://developer.android.com/training/appbar/action-views . Disclaimer Most of the information in this lecture has been compiled from the following sources: https://developer.android.com/training/appbar/ https://developer.android.com/guide/topics/ui/menus http://www.vogella.com/tutorials/AndroidActionBar/article.html","title":"App Bar"},{"location":"actionbar/#android-app-bar-aka-action-bar","text":"Abstract Lernziele Sie kennen die technischen Grundlagen der Android Action Bar Sie k\u00f6nnen eine Action Bar in ihre Applikation integrieren Sie verstehen wie sie Actions definieren und der Action Bar hinzuf\u00fcgen Note Note: The app bar should be implemented using the Android Toolbar to make it available for a wide range of devices. According to the Android developer guidelines, the appcompat Toolbar has the best compatibility support. Note Support Library has been superceded by Android Jetpack With the introduction of Android Jetpack and AndroidX, the support libraries are migrated into Android Jetpack for applications using API Level 28 (Android 9) and above. So if you plan to implement your application for Android Version > 8.0, you could use Android Jetpack instead of the support libaries (earlier versions still need to make use of the support libraries as outlined in this documentation). Source: https://developer.android.com/topic/libraries/support-library/setup","title":"Android App Bar (aka Action Bar)"},{"location":"actionbar/#introduction","text":"The app bar , also known as the action bar , is one of the most important design elements in your app\u2019s activities, because it provides a visual structure and interactive elements that are familiar to users. Using the app bar makes your app consistent with other Android apps , allowing users to quickly understand how to operate your app and have a great experience. The key functions of the app bar are as follows: A dedicated space for giving your app an identity and indicating the user\u2019s location in the app. Access to important actions in a predictable way, such as search. Support for navigation and view switching (with tabs or drop-down lists). This lecture describes how to use the v7 appcompat support library\u2019s Toolbar widget as an app bar. Note Note: There are other ways to implement an app bar\u2014for example, some themes set up an ActionBar as an app bar by default\u2014but using the appcompat Toolbar makes it easy to set up an app bar that works on the widest range of devices , and also gives you room to customize your app bar later on as your app develops.","title":"Introduction"},{"location":"actionbar/#choosing-the-app-bar-implementation","text":"In its most basic form, the action bar displays the title for the activity on one side and an overflow menu on the other. Even in this simple form, the app bar provides useful information to the users, and helps to give Android apps a consistent look and feel. An app bar with the app title and an overflow menu Beginning with Android 3.0 (API level 11), all activities that use the default theme have an ActionBar as an app bar. However, app bar features have gradually been added to the native ActionBar over various Android releases. As a result, the native ActionBar behaves differently depending on what version of the Android system a device may be using. By contrast, the most recent features are added to the support library\u2019s version of Toolbar , and they are available on any device that can use the support library. For this reason, it is recommended to use the support library\u2019s Toolbar class to implement activities\u2019 app bars . Using the support library\u2019s toolbar helps ensure that an app will have consistent behavior across the widest range of devices. For example, the Toolbar widget provides a material design experience on devices running Android 2.1 (API level 7) or later, but the native action bar doesn\u2019t support material design unless the device is running Android 5.0 (API level 21) or later.","title":"Choosing the App Bar Implementation"},{"location":"actionbar/#adding-a-toolbar-to-an-activity","text":"These steps describe how to set up a Toolbar as an activity\u2019s app bar:","title":"Adding a Toolbar to an Activity"},{"location":"actionbar/#set-the-necessary-support-libraries","text":"Add the v7 appcompat support library to your project, as described in Support Library Setup . In order to use a Support Library, you must modify the application\u2019s project\u2019s classpath dependencies within the development environment. This procedure must be performed for each Support Library that should be used. To add a Support Library to your application project, include Google\u2019s Maven repository in your top-level build.gradle file. 1 2 3 4 5 6 7 8 9 10 11 12 allprojects { repositories { google () // If you're using a version of Gradle lower than 4.1, you must // instead use: // // maven { // url 'https://maven.google.com' // } } } Then, add the support library to the dependencies section: 1 2 3 4 dependencies { ... implementation \"com.android.support:support-core-utils:27.1.1\" } Warning Note #1: The compile command in the dependencies section is deprecated by the end of 2018. Use implementation instead. Warning Note #2: Make sure that the :support-core-utils version number matches that of the :appcompat-v7 version number, otherwise runtime errors might occur. The following excerpt from the build.gradle (Module:app) file uses version 26.1.0 : 1 2 3 4 5 6 7 8 9 dependencies { implementation 'com.android.support:support-core-utils:26.1.0' implementation fileTree ( dir: 'libs' , include: [ '*.jar' ]) implementation 'com.android.support:appcompat-v7:26.1.0' implementation 'com.android.support.constraint:constraint-layout:1.1.1' testImplementation 'junit:junit:4.12' androidTestImplementation 'com.android.support.test:runner:1.0.2' androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2' }","title":"Set the necessary Support Libraries"},{"location":"actionbar/#extend-appcompatactivity","text":"Make sure the activity class extends AppCompatActivity , as illustrated below: 1 2 3 public class MyActivity extends AppCompatActivity { // ... } Note Note: You need to make this change for every activity in your app that uses a Toolbar as an app bar.","title":"Extend AppCompatActivity"},{"location":"actionbar/#set-the-noactionbar-theme","text":"In the app manifest , set the <application> element to use one of appcompat\u2019s NoActionBar themes. Using one of these themes prevents the app from using the native ActionBar class to provide the app bar. For example: 1 2 3 <application android:theme= \"@style/Theme.AppCompat.Light.NoActionBar\" />","title":"Set the NoActionBar Theme"},{"location":"actionbar/#set-the-toolbars-layout","text":"Add a Toolbar to the activity\u2019s layout. For example, the following layout code adds a Toolbar and gives it the appearance of floating above the activity: 1 2 3 4 5 6 7 8 <android.support.v7.widget.Toolbar android:id= \"@+id/my_toolbar\" android:layout_width= \"match_parent\" android:layout_height= \"?attr/actionBarSize\" android:background= \"?attr/colorPrimary\" android:elevation= \"4dp\" android:theme= \"@style/ThemeOverlay.AppCompat.ActionBar\" app:popupTheme= \"@style/ThemeOverlay.AppCompat.Light\" /> Note Note: The Material Design specification recommends that app bars should have an elevation of 4 dp . Position the toolbar at the top of the activity\u2019s layout, since you are using it as an app bar.","title":"Set the Toolbar's Layout"},{"location":"actionbar/#call-setsupportactionbar","text":"In the activity\u2019s onCreate() method, call the activity\u2019s setSupportActionBar() method, and pass the activity\u2019s toolbar. This method sets the toolbar as the app bar for the activity. For example: 1 2 3 4 5 6 7 @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_my ); Toolbar myToolbar = ( Toolbar ) findViewById ( R . id . my_toolbar ); setSupportActionBar ( myToolbar ); } Make sure that you import the correct Toolbar library, as illustrated below; otherwise the setSupportActionBar() method won\u2019t work. 1 import android.support.v7.widget.Toolbar ; Your app now has a basic action bar. By default, the action bar contains just the name of the app and an overflow menu. The options menu initially contains just the Settings item. You can add more actions to the action bar and the overflow menu, as described in the next Section \u2192 Adding and Handling Actions . Note Hint: Use App Bar Utility Methods Once you set the toolbar as an activity\u2019s app bar, you have access to the various utility methods provided by the v7 appcompat support library\u2019s ActionBar class. This approach lets you do a number of useful things, like hide and show the app bar. To use the ActionBar utility methods , call the activity\u2019s getSupportActionBar() method. This method returns a reference to an appcompat ActionBar object. Once you have that reference, you can call any of the ActionBar methods to adjust the app bar . For example, to hide the app bar, call ActionBar.hide() .","title":"Call setSupportActionBar()"},{"location":"actionbar/#defining-and-handling-actions","text":"The app bar allows you to add buttons for user actions . This feature lets you put the most important actions for the current context right at the top of the app. For example, a photo browsing app might show share and create album buttons at the top when the user is looking at their photo roll; when the user looks at an individual photo, the app might show crop and filter buttons. Space in the app bar is limited . If an app declares more actions than can fit in the app bar, the app bar send the excess actions to an overflow menu . The app can also specify that an action should always be shown in the overflow menu , instead of being displayed on the app bar. An app bar with a single action button and an overflow menu.","title":"Defining and Handling Actions"},{"location":"actionbar/#defining-action-buttons","text":"All action buttons and other items available in the action overflow are defined in an XML menu resource (\u2192 see https://developer.android.com/guide/topics/resources/menu-resource.html ). To add actions to the action bar, create a new XML file in your project\u2019s res/menu/ directory. The menu can be accessed (e.g. by the MenuInflater class) using R.menu.{name_of_your_menu_xml_file}.xml . Add an <item> element for each item you want to include in the action bar, as shown in the following code example of a menu XML file: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 <menu xmlns:android= \"http://schemas.android.com/apk/res/android\" > <!-- \"Mark Favorite\", should appear as action button if possible --> <item android:id= \"@+id/action_favorite\" android:icon= \"@drawable/ic_favorite_black_48dp\" android:title= \"@string/action_favorite\" app:showAsAction= \"ifRoom\" /> <!-- Settings, should always be in the overflow --> <item android:id= \"@+id/action_settings\" android:title= \"@string/action_settings\" app:showAsAction= \"never\" /> </menu> The app:showAsAction attribute specifies whether the action should be shown as a button on the app bar. If you set app:showAsAction=\"ifRoom\" (as in the example code\u2019s favorite action), the action is displayed as a button if there is room in the app bar for it; if there is not enough room, excess actions are sent to the overflow menu . If you set app:showAsAction=\"never\" (as in the example code\u2019s settings action), the action is always listed in the overflow menu , not displayed in the app bar. The system uses the action\u2019s icon as the action button, if the action is displayed in the app bar. You can find many useful icons on the Material Icons page.","title":"Defining Action Buttons"},{"location":"actionbar/#setting-actions-on-the-toolbar","text":"Warning Attention: This step is ommitted in the app bar\u2019s official google developer documents! Actions should be included in the options menu , which is part of the Toolbar if the application is developed for Android 3.0 (API level 11) and higher . By default, the system places all items in the action overflow , which the user can reveal with the action overflow icon on the right side of the app bar (or by pressing the device Menu button, if available). To enable quick access to important actions, you can promote a few items to appear in the app bar by adding android:showAsAction=\"ifRoom\" to the corresponding <item> elements (see Figure 3). The Google Play Movies app, showing a search button and the action overflow button. Note Hint: You can declare items for the options menu from either your Activity subclass or a Fragment subclass. If both your activity and fragment(s) declare items for the options menu, they are combined in the UI. The activity\u2019s items appear first, followed by those of each fragment in the order in which each fragment is added to the activity. If necessary, you can re-order the menu items with the android:orderInCategory attribute in each <item> you need to move. To specify the options menu for an activity, override onCreateOptionsMenu() (fragments provide their own onCreateOptionsMenu() callback). In this method, you can inflate your menu resource (defined in XML) into the Menu provided in the callback. For example: 1 2 3 4 5 6 @Override public boolean onCreateOptionsMenu ( Menu menu ) { MenuInflater inflater = getMenuInflater (); inflater . inflate ( R . menu . action_items , menu ); return true ; } You can also add menu items using add() and retrieve items with findItem() to revise their properties with MenuItem APIs. If you\u2019ve developed your application for Android 2.3.x and lower , the system calls onCreateOptionsMenu() to create the options menu when the user opens the menu for the first time. If you\u2019ve developed for Android 3.0 and higher , the system calls onCreateOptionsMenu() when starting the activity , in order to show items to the app bar .","title":"Setting Actions on the Toolbar"},{"location":"actionbar/#respond-to-actions","text":"When the user selects one of the app bar items, the system calls the activity\u2019s onOptionsItemSelected() callback method, and passes a MenuItem object to indicate which item was clicked. In your implementation of onOptionsItemSelected() , call the MenuItem.getItemId() method to determine which item was pressed. The ID returned matches the value you declared in the corresponding <item> element\u2019s android:id attribute. For example, the following code checks to see which action the user selected. If the method does not recognize the user\u2019s action, it invokes the superclass method: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Override public boolean onOptionsItemSelected ( MenuItem item ) { switch ( item . getItemId ()) { case R . id . action_settings : // User chose the \"Settings\" item, show the app settings UI... return true ; case R . id . action_favorite : // User chose the \"Favorite\" action, mark the current item // as a favorite... return true ; default: // If we got here, the user's action was not recognized. // Invoke the superclass to handle it. return super . onOptionsItemSelected ( item ); } }","title":"Respond to Actions"},{"location":"actionbar/#adding-an-up-action","text":"An app should make it easy for users to find their way back to the app\u2019s main screen. One simple way to do this is to provide an Up button on the app bar for all activities except the main one. When the user selects the Up button, the app navigates to the parent activity. This section shows you how to add an Up button to an activity by declaring the activity\u2019s parent in the manifest, and enabling the app bar\u2019s Up button.","title":"Adding an Up Action"},{"location":"actionbar/#declaring-a-parent-activity","text":"To support the up functionality in an activity, you need to declare the activity\u2019s parent . This is done in the app manifest , by setting an android:parentActivityName attribute. Note Note: The android:parentActivityName attribute was introduced in Android 4.1 (API level 16). To support devices with older versions of Android, define a <meta-data> name-value pair, where the name is \"android.support.PARENT_ACTIVITY\" and the value is the name of the parent activity. For example, suppose an app has a main activity named MainActivity and a single child activity. The following manifest code declares both activities, and specifies the parent/child relationship: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 <application ... > ... <!-- The main/home activity (it has no parent activity) --> <activity android:name= \"com.example.myfirstapp.MainActivity\" ... > ... </activity> <!-- A child of the main activity --> <activity android:name= \"com.example.myfirstapp.MyChildActivity\" android:label= \"@string/title_activity_child\" android:parentActivityName= \"com.example.myfirstapp.MainActivity\" > <!-- Parent activity meta-data to support 4.0 and lower --> <meta-data android:name= \"android.support.PARENT_ACTIVITY\" android:value= \"com.example.myfirstapp.MainActivity\" /> </activity> </application>","title":"Declaring a Parent Activity"},{"location":"actionbar/#enable-the-up-button","text":"To enable the Up button for an activity that has a parent activity, call the app bar\u2019s setDisplayHomeAsUpEnabled() method. Typically, this would be done when the activity is created. For example, the following onCreate() method sets a Toolbar as the app bar for MyChildActivity , then enables that app bar\u2019s Up button: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_my_child ); // my_child_toolbar is defined in the layout file Toolbar myChildToolbar = ( Toolbar ) findViewById ( R . id . my_child_toolbar ); setSupportActionBar ( myChildToolbar ); // Get a support ActionBar corresponding to this toolbar ActionBar ab = getSupportActionBar (); // Enable the Up button ab . setDisplayHomeAsUpEnabled ( true ); } There is no need to catch the up action in the activity\u2019s onOptionsItemSelected() method. Instead, that method should call its superclass, as shown in Respond to Actions. The superclass method responds to the Up selection by navigating to the parent activity, as specified in the app manifest.","title":"Enable the Up Button"},{"location":"actionbar/#action-views-and-action-providers","text":"Action Views and Action Providers are advanced topics and will not be covered in this lecture. However, more information can be found on the official android developer pages https://developer.android.com/training/appbar/action-views .","title":"Action Views and Action Providers"},{"location":"actionbar/#disclaimer","text":"Most of the information in this lecture has been compiled from the following sources: https://developer.android.com/training/appbar/ https://developer.android.com/guide/topics/ui/menus http://www.vogella.com/tutorials/AndroidActionBar/article.html","title":"Disclaimer"},{"location":"activities/","text":"Activities and Intents Abstract What you will learn You know the basic principles of Android Activies and Intents You are familiar with the application model of Android Applications You know how to add new Activities to an app and update the AndroidManifest.xml Activities An Activity represents a single screen in your app with which a user can perform a single, focused task such as taking a photo, sending an email, or viewing a map. An activity is usually presented to the user as a full-screen window . An app usually consists of multiple screens that are loosely bound to each other. Each screen is an activity . Main Acitivity Typically, one activity in an app is specified as the \u201cmain\u201d activity ( MainActivity.java ), which is presented to the user when the app is launched. The main activity can then start other activities to perform different actions. Runtime Logic Each time a new activity starts, the previous activity is stopped , but the system preserves the activity in a stack (the \u201cback stack\u201d). When a new activity starts, that new activity is pushed onto the back stack and takes user focus. The back stack follows basic \u201clast in, first out\u201d stack logic. When the user is done with the current activity and presses the Back button , that activity is popped from the stack and destroyed, and the previous activity resumes. Adding new Activities to an App Each new activity you add to your project has its own layout and Java files , separate from those of the main activity. They also have their own <activity> elements in the AndroidManifest.xml file. As with the main activity, new activity implementations that you create in Android Studio also extend from the AppCompatActivity class. Each activity in your app is only loosely connected with other activities. However, you can define an activity as a parent of another activity in the AndroidManifest.xml file. This parent-child relationship enables Android to add navigation hints such as left-facing arrows in the title bar for each activity. Example Example: Register a second activity in the AndroidManifest.xml 1 2 3 4 5 6 7 8 <activity android:name= \".SecondActivity\" android:label = \"Second Activity\" android:parentActivityName= \".MainActivity\" > <meta-data android:name= \"android.support.PARENT_ACTIVITY\" android:value= \"com.example.android.twoactivities.MainActivity\" /> </activity> Explanations: The label attribute adds the title of the Activity to the app bar. With the parentActivityName attribute, you indicate that the main activity is the parent of the second activity. This relationship is used for Up navigation in your app: the app bar for the second activity will have a left-facing arrow so the user can navigate \u201cupward\u201d to the main activity. With the <meta-data> element, you provide additional arbitrary information about the activity in the form of key-value pairs. In this case the metadata attributes do the same thing as the android:parentActivityName attribute \u2013 they define a relationship between two activities for upward navigation. These metadata attributes are required for older versions of Android, because the android:parentActivityName attribute is only available for API levels 16 and higher. Intents An activity is started or activated with an intent . An Intent is an asynchronous message that you can use in your activity to request an action from another activity, or from some other app component. You use an intent to start one activity from another activity, and to pass data between activities. An Intent can be explicit or implicit : An explicit intent is one in which the target of an intent is known. That is, you already know the fully qualified class name of that specific activity. An implicit intent is one in which you do not have the name of the target component, but you have a general action to perform. In NZSE and the practical sessions, you create explicit intents. Activity Life Cycle For more information see https://developer.android.com/guide/components/activities/activity-lifecycle#java Activities transiton through different states in their life cycle. The Activity class provides a number of callback methods that allow the activity to know that a state has changed: that the system is creating, stopping, or resuming an activity, or destroying the process in which the activity resides. Within the lifecycle callback methods , you can declare how an activity behaves when the user leaves and re-enters the activity. In other words, each callback allows you to perform specific work that\u2019s appropriate to a given change of state Note You don\u2019t need to implement all lifecycle methods Depending on the complexity of your activity, you probably don\u2019t need to implement all the lifecycle methods. However, it\u2019s important that you understand each one and implement those that ensure your app behaves the way users expect. onCreate () Called when the Activity is first created Contains the basic setup/startup logic for the application Use for actions that need to be performed only once in the lifetime of an Activity \u2013 e.g. bind data to list, views or adapters Receives the savedInstanceState parameter that contains the activity\u2019s previously saved state Perfoms the following actions call the super call to complete the creation process set the user interface layout for this activity recover the instance state inflation + initializing view widgets 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Override public void onCreate ( Bundle savedInstanceState ) { // call the super class onCreate to complete the creation of activity like // the view hierarchy super . onCreate ( savedInstanceState ); // recovering the instance state if ( savedInstanceState != null ) { gameState = savedInstanceState . getString ( GAME_STATE_KEY ); } // set the user interface layout for this activity // the layout file is defined in the project res/layout/main_activity.xml file setContentView ( R . layout . main_activity ); // initialize member TextView so we can manipulate it later textView = ( TextView ) findViewById ( R . id . text_view ); } onStart () Invoked when the system enters the STARTED state, previously before the activity enters the foreground onStart () makes the activity visible to the user Use for the initialization of the code that maintains the UI Activity only remains very shortly in this state; when the callback finishes the activity transitions to the RESUMED state onResume () Invoked when the activity comes to the foreground (it is visible and in the foreground) Activity remains in the RESUMED state and user can interakt with it Activity stays in this state until something happens that takes the focus away from the app/activity (e.g. a receiving phone call; the navigation to another activity; device screen turning off etc.) When an interruptive event occurs, the activity enters the PAUSED state, and the system invokes the onPause () callback. If the activity returns to the RESUMED state from the PAUSED state, the system once again calls onResume () method. For this reason, you should implement onResume () to initialize components that you release during onPause () , and perform any other initializations that must occur each time the activity enters the RESUMED state. onPause () First action when the user leaves the activity Activity is no longer in the foreground Use onPause () to adjust or pause operations that should not continue while the activity is in PAUSED state but resume afterwards Release system resources (e.g. sensor handlers such as GPS etc or resources that affect battery life) Warning Do not use onPause () for Data Saving Operations onPause () execution is very brief, and does not necessarily afford enough time to perform save operations. For this reason, you should not use onPause () to save application or user data, make network calls, or execute database transactions; such work may not complete before the method completes. Instead, you should perform heavy-load shutdown operations during onStop () . Completion of the onPause() method does not mean that the activity leaves the Paused state. Rather, the activity remains in this state until either the activity resumes or becomes completely invisible to the user. If the activity resumes, the system once again invokes the onResume() callback. onStop () When your activity is no longer visible to the user, it has entered the STOPPED state, and the system invokes the onStop () callback. Called when the activity has finished running and is about to be terminated Release any resources that are not needed while the app is not visible to the user Using onStop () instead of onPasue () ensures that UI-related work continues Use for CPU-intensive shutdown operations \u2013 e.g., store data in a database onDestroy () Called before the activity is destroyed 2 Reasons the activity is finishing (due to the user completely dismissing the activity or due to finish() being called on the activity), or the system is temporarily destroying the activity due to a configuration change (such as device rotation or multi-window mode) What you have Learned Abstract After having finished this lession, you know\u2026 \u2026how to create Activities and Intents \u2026how the Application Model in Android works \u2026how you can use Intents to call Activities and share data between them.","title":"Activities & Intents"},{"location":"activities/#activities-and-intents","text":"Abstract What you will learn You know the basic principles of Android Activies and Intents You are familiar with the application model of Android Applications You know how to add new Activities to an app and update the AndroidManifest.xml","title":"Activities and Intents"},{"location":"activities/#activities","text":"An Activity represents a single screen in your app with which a user can perform a single, focused task such as taking a photo, sending an email, or viewing a map. An activity is usually presented to the user as a full-screen window . An app usually consists of multiple screens that are loosely bound to each other. Each screen is an activity .","title":"Activities"},{"location":"activities/#main-acitivity","text":"Typically, one activity in an app is specified as the \u201cmain\u201d activity ( MainActivity.java ), which is presented to the user when the app is launched. The main activity can then start other activities to perform different actions.","title":"Main Acitivity"},{"location":"activities/#runtime-logic","text":"Each time a new activity starts, the previous activity is stopped , but the system preserves the activity in a stack (the \u201cback stack\u201d). When a new activity starts, that new activity is pushed onto the back stack and takes user focus. The back stack follows basic \u201clast in, first out\u201d stack logic. When the user is done with the current activity and presses the Back button , that activity is popped from the stack and destroyed, and the previous activity resumes.","title":"Runtime Logic"},{"location":"activities/#adding-new-activities-to-an-app","text":"Each new activity you add to your project has its own layout and Java files , separate from those of the main activity. They also have their own <activity> elements in the AndroidManifest.xml file. As with the main activity, new activity implementations that you create in Android Studio also extend from the AppCompatActivity class. Each activity in your app is only loosely connected with other activities. However, you can define an activity as a parent of another activity in the AndroidManifest.xml file. This parent-child relationship enables Android to add navigation hints such as left-facing arrows in the title bar for each activity. Example Example: Register a second activity in the AndroidManifest.xml 1 2 3 4 5 6 7 8 <activity android:name= \".SecondActivity\" android:label = \"Second Activity\" android:parentActivityName= \".MainActivity\" > <meta-data android:name= \"android.support.PARENT_ACTIVITY\" android:value= \"com.example.android.twoactivities.MainActivity\" /> </activity> Explanations: The label attribute adds the title of the Activity to the app bar. With the parentActivityName attribute, you indicate that the main activity is the parent of the second activity. This relationship is used for Up navigation in your app: the app bar for the second activity will have a left-facing arrow so the user can navigate \u201cupward\u201d to the main activity. With the <meta-data> element, you provide additional arbitrary information about the activity in the form of key-value pairs. In this case the metadata attributes do the same thing as the android:parentActivityName attribute \u2013 they define a relationship between two activities for upward navigation. These metadata attributes are required for older versions of Android, because the android:parentActivityName attribute is only available for API levels 16 and higher.","title":"Adding new Activities to an App"},{"location":"activities/#intents","text":"An activity is started or activated with an intent . An Intent is an asynchronous message that you can use in your activity to request an action from another activity, or from some other app component. You use an intent to start one activity from another activity, and to pass data between activities. An Intent can be explicit or implicit : An explicit intent is one in which the target of an intent is known. That is, you already know the fully qualified class name of that specific activity. An implicit intent is one in which you do not have the name of the target component, but you have a general action to perform. In NZSE and the practical sessions, you create explicit intents.","title":"Intents"},{"location":"activities/#activity-life-cycle","text":"For more information see https://developer.android.com/guide/components/activities/activity-lifecycle#java Activities transiton through different states in their life cycle. The Activity class provides a number of callback methods that allow the activity to know that a state has changed: that the system is creating, stopping, or resuming an activity, or destroying the process in which the activity resides. Within the lifecycle callback methods , you can declare how an activity behaves when the user leaves and re-enters the activity. In other words, each callback allows you to perform specific work that\u2019s appropriate to a given change of state Note You don\u2019t need to implement all lifecycle methods Depending on the complexity of your activity, you probably don\u2019t need to implement all the lifecycle methods. However, it\u2019s important that you understand each one and implement those that ensure your app behaves the way users expect. onCreate () Called when the Activity is first created Contains the basic setup/startup logic for the application Use for actions that need to be performed only once in the lifetime of an Activity \u2013 e.g. bind data to list, views or adapters Receives the savedInstanceState parameter that contains the activity\u2019s previously saved state Perfoms the following actions call the super call to complete the creation process set the user interface layout for this activity recover the instance state inflation + initializing view widgets 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Override public void onCreate ( Bundle savedInstanceState ) { // call the super class onCreate to complete the creation of activity like // the view hierarchy super . onCreate ( savedInstanceState ); // recovering the instance state if ( savedInstanceState != null ) { gameState = savedInstanceState . getString ( GAME_STATE_KEY ); } // set the user interface layout for this activity // the layout file is defined in the project res/layout/main_activity.xml file setContentView ( R . layout . main_activity ); // initialize member TextView so we can manipulate it later textView = ( TextView ) findViewById ( R . id . text_view ); } onStart () Invoked when the system enters the STARTED state, previously before the activity enters the foreground onStart () makes the activity visible to the user Use for the initialization of the code that maintains the UI Activity only remains very shortly in this state; when the callback finishes the activity transitions to the RESUMED state onResume () Invoked when the activity comes to the foreground (it is visible and in the foreground) Activity remains in the RESUMED state and user can interakt with it Activity stays in this state until something happens that takes the focus away from the app/activity (e.g. a receiving phone call; the navigation to another activity; device screen turning off etc.) When an interruptive event occurs, the activity enters the PAUSED state, and the system invokes the onPause () callback. If the activity returns to the RESUMED state from the PAUSED state, the system once again calls onResume () method. For this reason, you should implement onResume () to initialize components that you release during onPause () , and perform any other initializations that must occur each time the activity enters the RESUMED state. onPause () First action when the user leaves the activity Activity is no longer in the foreground Use onPause () to adjust or pause operations that should not continue while the activity is in PAUSED state but resume afterwards Release system resources (e.g. sensor handlers such as GPS etc or resources that affect battery life) Warning Do not use onPause () for Data Saving Operations onPause () execution is very brief, and does not necessarily afford enough time to perform save operations. For this reason, you should not use onPause () to save application or user data, make network calls, or execute database transactions; such work may not complete before the method completes. Instead, you should perform heavy-load shutdown operations during onStop () . Completion of the onPause() method does not mean that the activity leaves the Paused state. Rather, the activity remains in this state until either the activity resumes or becomes completely invisible to the user. If the activity resumes, the system once again invokes the onResume() callback. onStop () When your activity is no longer visible to the user, it has entered the STOPPED state, and the system invokes the onStop () callback. Called when the activity has finished running and is about to be terminated Release any resources that are not needed while the app is not visible to the user Using onStop () instead of onPasue () ensures that UI-related work continues Use for CPU-intensive shutdown operations \u2013 e.g., store data in a database onDestroy () Called before the activity is destroyed 2 Reasons the activity is finishing (due to the user completely dismissing the activity or due to finish() being called on the activity), or the system is temporarily destroying the activity due to a configuration change (such as device rotation or multi-window mode)","title":"Activity Life Cycle"},{"location":"activities/#what-you-have-learned","text":"Abstract After having finished this lession, you know\u2026 \u2026how to create Activities and Intents \u2026how the Application Model in Android works \u2026how you can use Intents to call Activities and share data between them.","title":"What you have Learned"},{"location":"asynctask/","text":"AsyncTask: Concurrent Programming in Android Abstract Objectives You know the basic constituents of Android\u2019s AsyncTask You know how to subclass the AsyncTask class You can use AsyncTask to outsource computationally extensive tasks from the UI thread Introduction AsyncTask enables to keep the UI thread from having to perform computational expensive operations. This class allows you to perform background operations asynchronously and publish results on the UI thread without having to manipulate threads and/or handlers. AsyncTask is designed to be a helper class around Thread and Handler and does not constitute a generic threading framework. AsyncTasks should ideally be used for short operations (a few seconds at the most). Note Use a Threading Framework for Long-Running Operations If you need to keep threads running for long periods of time, it is highly recommended you use the various APIs provided by the java.util.concurrent package such as Executor , ThreadPoolExecutor and FutureTask . Structure An asynchronous task is defined by 3 generic types : Params \u2013 the type of the parameters sent to the task upon execution. Progress \u2013 the type of the progress units published during the background computation. Result \u2013 the type of the result of the background computation. Note Set Unused Types to Void Not all types are always used by an asynchronous task. To mark a type as unused, simply use the type Void : private class MyTask extends AsyncTask < Void , Void , Void > { ... } An asynchronous task defines 4 callback methods (= steps ); when an asynchronous task is executed, the task goes through the following steps onPreExecute () invoked on the UI thread before the task is executed. This step is normally used to setup the task, for instance, by showing a progress bar in the UI. doInBackground ( Params ...) invoked on the background thread immediately after onPreExecute () finished execution. This step is used to perform background computation that can take a long time. The Params parameters of the asynchronous task are passed to this step. The result of the computation must be returned by this step and will be passed to onPostExecute ( Result ) . This step can also use publishProgress ( Progress ...) to publish one or more units of progress. These values are published on the UI thread, in the onProgressUpdate ( Progress ...) step. onProgressUpdate ( Progress ...) invoked on the UI thread after a call to publishProgress ( Progress ...) . The timing of the execution is undefined. This method is used to display any form of progress in the user interface while the background computation is still executing. For instance, it can be used to animate a progress bar or show logs in a text field. onPostExecute ( Result ) invoked on the UI thread after the background computation finishes. The result of the background computation is passed to this callback method as a parameter. Note Pay Attention to where a Method is Executed Please pay close attention to which methods are exectuted by the UI thread and which by the background thread . This distinction is important as UI elements (= views defined in the activity\u2019s layout ) can only by manipulated by the UI thread. Trying to manipulate them from a method executed by the background thread will result in an exception and termination. Usage AsyncTask must be subclassed to be used. The subclass will override at least one method ( doInBackground ( Params ...) ), and most often will override a second one ( onPostExecute ( Result ) ). The following example from the official documentation demonstrates the usage of AsyncTask: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 private class DownloadFilesTask extends AsyncTask < URL , Integer , Long > { protected Long doInBackground ( URL ... urls ) { int count = urls . length ; long totalSize = 0 ; for ( int i = 0 ; i < count ; i ++ ) { totalSize += Downloader . downloadFile ( urls [ i ] ); publishProgress (( int ) (( i / ( float ) count ) * 100 )); // Escape early if cancel() is called if ( isCancelled ()) break ; } return totalSize ; } protected void onProgressUpdate ( Integer ... progress ) { setProgressPercent ( progress [ 0 ] ); } protected void onPostExecute ( Long result ) { showDialog ( \"Downloaded \" + result + \" bytes\" ); } } Once created, an instance of the task can be created and executed rather simply: 1 new DownloadFilesTask (). execute ( url1 , url2 , url3 ); Canceling a Task A task can be cancelled at any time by invoking cancel ( boolean ) . Invoking this method will cause subsequent calls to isCancelled () to return true. After invoking this method, onCancelled ( java . lang . Object ) , instead of onPostExecute ( java . lang . Object ) will be invoked after doInBackground ( java . lang . Object [] returns. To ensure that a task is cancelled as quickly as possible, you should always check the return value of isCancelled () periodically from doInBackground ( java . lang . Object []) , if possible (inside a loop for instance.) Threading Rules There are a few threading rules that must be followed for this class to work properly : The AsyncTask class MUST be loaded on the UI thread . This is done automatically as of Build.VERSION_CODES.JELLY_BEAN . The task instance MUST be created on the UI thread. execute ( Params ...) MUST be invoked on the UI thread. Do NOT call onPreExecute () , onPostExecute ( Result ) , doInBackground ( Params ...) , onProgressUpdate ( Progress ...) manually. The task can be executed only once (an exception will be thrown if a second execution is attempted.) Examples Example #1: Subclassing AsyncTask 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 public class ScanChannelsTask extends AsyncTask < String , Integer , JSONObject > { public static final String TAG = ScanChannelsTask . class . getSimpleName (); private Context context ; private HttpRequest request ; private boolean running ; private Handler handler ; public ScanChannelsTask ( HttpRequest request , Context context , Handler handler ) { this . request = request ; this . context = context ; this . handler = handler ; } /** * Set the message handler through which the {@link AsyncTask} can communicate with * its main (ie. calling) activity * @param handler */ public void setHandler ( Handler handler ) { this . handler = handler ; } @Override /** * This method contains the actual task's logic, ie., * the computational steps the task is intended to perform. * Here the method takes the TV-Simulator's IP and command * in form of a {@link String} and performs the HTTP request. * The result will be passed to a JSON object */ protected JSONObject doInBackground ( String [] params ) { JSONObject obj = null ; if ( params [ 0 ] != null ) { try { obj = this . request . sendHttp ( params [ 0 ] ); } catch ( IOException e ) { e . printStackTrace (); } catch ( JSONException e ) { e . printStackTrace (); } } return obj ; // don't forget to return result for/to onPostExecute() } @Override /** * Method is called from the UI thread. * Creates a Toast message to indicate that the task is running */ protected void onPreExecute () { Toast . makeText ( this . context , \"Started Channel Scan\" , Toast . LENGTH_SHORT ). show (); } @Override /** * From this method, it is possible to modify the UI * since it is executed in the main UI Thread */ protected void onPostExecute ( JSONObject jsonObject ) { super . onPostExecute ( jsonObject ); try { JSONArray json_channels = jsonObject . getJSONArray ( \"channels\" ); JSONObject obj = ( JSONObject ) json_channels . get ( 0 ); // trying to obtain first channel obj. } catch ( JSONException e ) { e . printStackTrace (); } // Send data to the activity to have them displayed in the log window Message msg = new Message (); Bundle bundle = new Bundle (); bundle . putString ( MainActivity . HANDLER_MESSAGE_KEY , jsonObject . toString ()); msg . setData ( bundle ); this . handler . sendMessage ( msg ); Toast . makeText ( this . context , \"Channel Scan finished\" , Toast . LENGTH_SHORT ). show (); } } Example #2: Passing Runnable to AsyncTask\u2019s execute Method 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 /** * Sends the content from txtCommand widget as command to TV Server * * Shows Option #2 on instantiating an {@link AsyncTask} * * {@link AsyncTask}s can also be instantiated by implementing the {@link Runnable} interface * (and its run() method) in form of an annonymous inner class that is passed as argument to * the {@link AsyncTask}'s execute() method */ public void sendCommandToTvServer ( View view ) { final String command = txtCommand . getText (). toString (); txtResponse . append ( \"\\nSending Command to TV Server: \" + command ); AsyncTask . execute ( new Runnable () { @Override public void run () { try { JSONObject obj = httpRequest . execute ( command ); Message msg = new Message (); Bundle bundle = new Bundle (); bundle . putString ( MainActivity . HANDLER_MESSAGE_KEY , obj . toString ()); msg . setData ( bundle ); /* Example #1 SZA: It is important to use sendMessage here; otherwise an Exception is thrown (see Example #3) */ mMessageHandler . sendMessage ( msg ); // /* Example #2 Alternatively, view updates can be issued via implementing the Runnable Interface and passing it to the view's post()-method as an anonymous inner class. That way, UI thread elements can be updated from background threads See https://stackoverflow.com/questions/13840007/what-exactly-does-the-post-method-do */ txtResponse . post ( new Runnable () { @Override public void run () { txtResponse . append ( \"\\nResult created...\" ); } }) ; /* Example #3 SZA: Doesn't work --> Main views can not be modified from runnable objects; only main thread can update its views */ // txtResponse.setText(\"\\n\"+ obj.toString()); } catch ( IOException e ) { e . printStackTrace (); } catch ( JSONException e ) { e . printStackTrace (); } } }); } What you have Learned Abstract After having finished this lession, you know \u2026how to the basic types and callback methods of Android\u2019s AsyncTask \u2026how to implement an AsyncTask for an individual task \u2026the responsibilities of each callback method \u2026which callback methods are called by the UI thread and which by the background thread \u2026how to send data from the AsyncTask to the UI thread Disclaimer Most of the information in this lecture has been compiled from the official Android documentation pages: https://developer.android.com/reference/android/os/AsyncTask","title":"AsyncTask"},{"location":"asynctask/#asynctask-concurrent-programming-in-android","text":"Abstract Objectives You know the basic constituents of Android\u2019s AsyncTask You know how to subclass the AsyncTask class You can use AsyncTask to outsource computationally extensive tasks from the UI thread","title":"AsyncTask: Concurrent Programming in Android"},{"location":"asynctask/#introduction","text":"AsyncTask enables to keep the UI thread from having to perform computational expensive operations. This class allows you to perform background operations asynchronously and publish results on the UI thread without having to manipulate threads and/or handlers. AsyncTask is designed to be a helper class around Thread and Handler and does not constitute a generic threading framework. AsyncTasks should ideally be used for short operations (a few seconds at the most). Note Use a Threading Framework for Long-Running Operations If you need to keep threads running for long periods of time, it is highly recommended you use the various APIs provided by the java.util.concurrent package such as Executor , ThreadPoolExecutor and FutureTask .","title":"Introduction"},{"location":"asynctask/#structure","text":"An asynchronous task is defined by 3 generic types : Params \u2013 the type of the parameters sent to the task upon execution. Progress \u2013 the type of the progress units published during the background computation. Result \u2013 the type of the result of the background computation. Note Set Unused Types to Void Not all types are always used by an asynchronous task. To mark a type as unused, simply use the type Void : private class MyTask extends AsyncTask < Void , Void , Void > { ... } An asynchronous task defines 4 callback methods (= steps ); when an asynchronous task is executed, the task goes through the following steps onPreExecute () invoked on the UI thread before the task is executed. This step is normally used to setup the task, for instance, by showing a progress bar in the UI. doInBackground ( Params ...) invoked on the background thread immediately after onPreExecute () finished execution. This step is used to perform background computation that can take a long time. The Params parameters of the asynchronous task are passed to this step. The result of the computation must be returned by this step and will be passed to onPostExecute ( Result ) . This step can also use publishProgress ( Progress ...) to publish one or more units of progress. These values are published on the UI thread, in the onProgressUpdate ( Progress ...) step. onProgressUpdate ( Progress ...) invoked on the UI thread after a call to publishProgress ( Progress ...) . The timing of the execution is undefined. This method is used to display any form of progress in the user interface while the background computation is still executing. For instance, it can be used to animate a progress bar or show logs in a text field. onPostExecute ( Result ) invoked on the UI thread after the background computation finishes. The result of the background computation is passed to this callback method as a parameter. Note Pay Attention to where a Method is Executed Please pay close attention to which methods are exectuted by the UI thread and which by the background thread . This distinction is important as UI elements (= views defined in the activity\u2019s layout ) can only by manipulated by the UI thread. Trying to manipulate them from a method executed by the background thread will result in an exception and termination.","title":"Structure"},{"location":"asynctask/#usage","text":"AsyncTask must be subclassed to be used. The subclass will override at least one method ( doInBackground ( Params ...) ), and most often will override a second one ( onPostExecute ( Result ) ). The following example from the official documentation demonstrates the usage of AsyncTask: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 private class DownloadFilesTask extends AsyncTask < URL , Integer , Long > { protected Long doInBackground ( URL ... urls ) { int count = urls . length ; long totalSize = 0 ; for ( int i = 0 ; i < count ; i ++ ) { totalSize += Downloader . downloadFile ( urls [ i ] ); publishProgress (( int ) (( i / ( float ) count ) * 100 )); // Escape early if cancel() is called if ( isCancelled ()) break ; } return totalSize ; } protected void onProgressUpdate ( Integer ... progress ) { setProgressPercent ( progress [ 0 ] ); } protected void onPostExecute ( Long result ) { showDialog ( \"Downloaded \" + result + \" bytes\" ); } } Once created, an instance of the task can be created and executed rather simply: 1 new DownloadFilesTask (). execute ( url1 , url2 , url3 );","title":"Usage"},{"location":"asynctask/#canceling-a-task","text":"A task can be cancelled at any time by invoking cancel ( boolean ) . Invoking this method will cause subsequent calls to isCancelled () to return true. After invoking this method, onCancelled ( java . lang . Object ) , instead of onPostExecute ( java . lang . Object ) will be invoked after doInBackground ( java . lang . Object [] returns. To ensure that a task is cancelled as quickly as possible, you should always check the return value of isCancelled () periodically from doInBackground ( java . lang . Object []) , if possible (inside a loop for instance.)","title":"Canceling a Task"},{"location":"asynctask/#threading-rules","text":"There are a few threading rules that must be followed for this class to work properly : The AsyncTask class MUST be loaded on the UI thread . This is done automatically as of Build.VERSION_CODES.JELLY_BEAN . The task instance MUST be created on the UI thread. execute ( Params ...) MUST be invoked on the UI thread. Do NOT call onPreExecute () , onPostExecute ( Result ) , doInBackground ( Params ...) , onProgressUpdate ( Progress ...) manually. The task can be executed only once (an exception will be thrown if a second execution is attempted.)","title":"Threading Rules"},{"location":"asynctask/#examples","text":"","title":"Examples"},{"location":"asynctask/#example-1-subclassing-asynctask","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 public class ScanChannelsTask extends AsyncTask < String , Integer , JSONObject > { public static final String TAG = ScanChannelsTask . class . getSimpleName (); private Context context ; private HttpRequest request ; private boolean running ; private Handler handler ; public ScanChannelsTask ( HttpRequest request , Context context , Handler handler ) { this . request = request ; this . context = context ; this . handler = handler ; } /** * Set the message handler through which the {@link AsyncTask} can communicate with * its main (ie. calling) activity * @param handler */ public void setHandler ( Handler handler ) { this . handler = handler ; } @Override /** * This method contains the actual task's logic, ie., * the computational steps the task is intended to perform. * Here the method takes the TV-Simulator's IP and command * in form of a {@link String} and performs the HTTP request. * The result will be passed to a JSON object */ protected JSONObject doInBackground ( String [] params ) { JSONObject obj = null ; if ( params [ 0 ] != null ) { try { obj = this . request . sendHttp ( params [ 0 ] ); } catch ( IOException e ) { e . printStackTrace (); } catch ( JSONException e ) { e . printStackTrace (); } } return obj ; // don't forget to return result for/to onPostExecute() } @Override /** * Method is called from the UI thread. * Creates a Toast message to indicate that the task is running */ protected void onPreExecute () { Toast . makeText ( this . context , \"Started Channel Scan\" , Toast . LENGTH_SHORT ). show (); } @Override /** * From this method, it is possible to modify the UI * since it is executed in the main UI Thread */ protected void onPostExecute ( JSONObject jsonObject ) { super . onPostExecute ( jsonObject ); try { JSONArray json_channels = jsonObject . getJSONArray ( \"channels\" ); JSONObject obj = ( JSONObject ) json_channels . get ( 0 ); // trying to obtain first channel obj. } catch ( JSONException e ) { e . printStackTrace (); } // Send data to the activity to have them displayed in the log window Message msg = new Message (); Bundle bundle = new Bundle (); bundle . putString ( MainActivity . HANDLER_MESSAGE_KEY , jsonObject . toString ()); msg . setData ( bundle ); this . handler . sendMessage ( msg ); Toast . makeText ( this . context , \"Channel Scan finished\" , Toast . LENGTH_SHORT ). show (); } }","title":"Example #1: Subclassing AsyncTask"},{"location":"asynctask/#example-2-passing-runnable-to-asynctasks-execute-method","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 /** * Sends the content from txtCommand widget as command to TV Server * * Shows Option #2 on instantiating an {@link AsyncTask} * * {@link AsyncTask}s can also be instantiated by implementing the {@link Runnable} interface * (and its run() method) in form of an annonymous inner class that is passed as argument to * the {@link AsyncTask}'s execute() method */ public void sendCommandToTvServer ( View view ) { final String command = txtCommand . getText (). toString (); txtResponse . append ( \"\\nSending Command to TV Server: \" + command ); AsyncTask . execute ( new Runnable () { @Override public void run () { try { JSONObject obj = httpRequest . execute ( command ); Message msg = new Message (); Bundle bundle = new Bundle (); bundle . putString ( MainActivity . HANDLER_MESSAGE_KEY , obj . toString ()); msg . setData ( bundle ); /* Example #1 SZA: It is important to use sendMessage here; otherwise an Exception is thrown (see Example #3) */ mMessageHandler . sendMessage ( msg ); // /* Example #2 Alternatively, view updates can be issued via implementing the Runnable Interface and passing it to the view's post()-method as an anonymous inner class. That way, UI thread elements can be updated from background threads See https://stackoverflow.com/questions/13840007/what-exactly-does-the-post-method-do */ txtResponse . post ( new Runnable () { @Override public void run () { txtResponse . append ( \"\\nResult created...\" ); } }) ; /* Example #3 SZA: Doesn't work --> Main views can not be modified from runnable objects; only main thread can update its views */ // txtResponse.setText(\"\\n\"+ obj.toString()); } catch ( IOException e ) { e . printStackTrace (); } catch ( JSONException e ) { e . printStackTrace (); } } }); }","title":"Example #2: Passing Runnable to AsyncTask's execute Method"},{"location":"asynctask/#what-you-have-learned","text":"Abstract After having finished this lession, you know \u2026how to the basic types and callback methods of Android\u2019s AsyncTask \u2026how to implement an AsyncTask for an individual task \u2026the responsibilities of each callback method \u2026which callback methods are called by the UI thread and which by the background thread \u2026how to send data from the AsyncTask to the UI thread","title":"What you have Learned"},{"location":"asynctask/#disclaimer","text":"Most of the information in this lecture has been compiled from the official Android documentation pages: https://developer.android.com/reference/android/os/AsyncTask","title":"Disclaimer"},{"location":"data_storage/","text":"Daten-Speicherung in Android Last Updated: 2019-06-04 Abstract Lernziele Sie kennen die verschiedenen M\u00f6glichkeiten, wie sich Daten unter Android persistent speichern lassen Sie kennen die Vor- und Nachteile der verschiedenen Speicherm\u00f6glichkeiten Sie k\u00f6nnen die hier vorgestellten Speichermechanismen in einer Android App implementieren bzw. f\u00fcr einen konkreten Anwendungsfall einsetzen Note Hinweis : Die hier vorgestellten Informationen stammen aus der hervorragenden Zusammenschrift der Seite https://www.big-app.de/daten-speicher-in-android/ Update : Nachstehend finden sich die Beispiele zur Speicherung von Zust\u00e4nden von UI-Elementen aus der Vorlesung: Speicherung von Zustandsinformationen im internen Speicher des Ger\u00e4tes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 private boolean saveState () { try { DataOutputStream dos = new DataOutputStream ( openFileOutput ( FILENAME , MODE_PRIVATE )); dos . writeInt ( sekVolume . getProgress ()); dos . flush (); dos . close (); lblMessage . append ( \"\\n\\nState successfully stored...\" ); return true ; } catch ( FileNotFoundException e ) { lblMessage . setText ( e . getMessage ()); e . printStackTrace (); } catch ( IOException e ) { lblMessage . setText ( e . getMessage ()); e . printStackTrace (); } return false ; } Laden von Zustandsinformationen aus dem internen Speicher: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 private boolean loadState () { try { DataInputStream dis = new DataInputStream ( openFileInput ( FILENAME )); int volume = dis . readInt (); if ( volume > lowerBound && volume < upperBound ) { sekVolume . setProgress ( volume ); } dis . close (); lblMessage . append ( \"\\nState successfully loaded...\" ); return true ; } catch ( IOException e ) { lblMessage . setText ( e . getMessage ()); e . printStackTrace (); } return false ; } Laden von Zustandsinformationen beim Erzeugen der Activity in onCreate() : 1 2 3 4 5 6 File file = new File ( getApplicationContext (). getFilesDir (), FILENAME ); if ( file . exists ()) { loadState (); } else { lblMessage . append ( \"\\n\\nFile not found...\" ); } Welche Daten-Speicher gibt es in Android? F\u00fcr die Speicherung persistenter Daten bietet Android mehrere L\u00f6sungen an, die von den Bed\u00fcrfnissen und W\u00fcnschen des Android-Entwicklers abh\u00e4ngig sind. So gibt es mehrere Daten-Speicher , die die Daten entweder privat ablegen oder f\u00fcr andere Apps bzw. Benutzer \u00f6ffentlich zur Verf\u00fcgung stellen. Zudem ist die Wahl der Speicherl\u00f6sung davon abh\u00e4ngig, wieviel Speicherplatz die Daten ben\u00f6tigen und auf welche Weise die Daten gespeichert werden sollen. Man unterscheidet allgemein zwischen folgenden Speicherl\u00f6sungen: Speicher-L\u00f6sungen in Android (auf dem Ger\u00e4t) : Interner / Externer Speicher SQLite-Datenbank SharedPreferences Content Provider Speicher-L\u00f6sungen au\u00dferhalb von Android (au\u00dferhalb des Ger\u00e4ts): Netzwerkspeicher Firebase Cloud etc. Note Info : In diesem Artikel wird lediglich ein \u00dcberblick zu den verschiedenen Speicherl\u00f6sungen in Android gegeben und nicht zu sehr ins Detail gegangen. Zudem geht der Artikel nicht auf die Speicherl\u00f6sungen au\u00dferhalb von Android ein. Interner Speicher Bei dieser Speicherl\u00f6sung werden Daten standardm\u00e4\u00dfig als \u201c privat \u201d im internen Speicher des Ger\u00e4ts abgelegt, d.h. eine fremde App hat keinen Zugriff auf diese Daten. Die Daten werden auch nur solange im internen Speicher gehalten, bis der Benutzer die App vom Ger\u00e4t entfernt. Im internen Speicher k\u00f6nnen dabei z.B. folgende Dateien abgespeichert werden: Texte Bilder Videos Lieder Diese Dateien werden auf dem Ger\u00e4t im Verzeichnis data/data/package_name/files abgelegt und sind permanent vorhanden. Eine App hat zudem immer eine Schreib- und Lese-Berechtigung f\u00fcr den internen Speicher und es muss somit keine entsprechende Berechtigung in die Manifest-Datei eingetragen werden. Es gibt auf dem Ger\u00e4t zwei unterschiedliche Verzeichnisse , die sich nach der Speicherart unterscheiden: Permanenter Speicher : F\u00fcr dauerhafte Daten, die \u00fcber getFilesDir() erreichbar sind Tempor\u00e4rer Speicher : F\u00fcr Cache-Daten, die \u00fcber getCacheDir() erreichbar sind Einsatzzweck Diese Speicherl\u00f6sung ist ideal, wenn du sicher sein m\u00f6chtest, dass weder der Benutzer noch andere Apps auf deine Dateien zugreifen k\u00f6nnen sollen. Schreiben der Daten Um Daten in den internen Speicher schreiben zu k\u00f6nnen, rufst du die Methode openFileOutput() mit dem Namen der Datei und dem Modus auf. Als Modus kannst du, je nach Verwendungszweck, die folgenden beiden Modi verwenden: MODE_PRIVATE : Es wird eine private Datei erstellt, d.h. nur die eigenen App hat Zugriff darauf MODE_APPEND : Wenn eine Datei bereits existiert, dann werden Daten ans Datei-Ende geschrieben Die Methode openFileOutput() gibt eine Instanz von FileOutputStream zur\u00fcck, mit der du dann die Methode write() aufrufen kannst, um in die Datei schreiben zu k\u00f6nnen. Am Schluss schlie\u00dft du den Datenstrom mit der close() -Methode. Beispiel: 1 2 3 4 5 String s_text = \"Beispieltext\" ; FileOutputStream myFOS = openFileOutput ( \"dateiname.txt\" , MODE_PRIVATE ); myFOS . write ( s_text . getBytes ()); myFOS . close (); Lesen der Daten: Um aus der soeben erstellten Datei lesen zu k\u00f6nnen, rufst du die Methode openFileInput() mit dem Namen der Datei auf und bekommst als R\u00fcckgabewert eine Instanz von FileInputStream zur\u00fcck. Danach rufst du mit dieser Instanz die read() -Methode auf, um aus der Datei byteweise zu lesen. Am Ende schlie\u00dft du den Datenstrom wieder \u00fcber die close() -Methode. Beispiel: 1 2 3 4 5 6 7 FileInputStream myFIS = openFileInput ( \"dateiname.txt\" ); int i_character ; String s_temp = \"\" ; while ( ( i_character = myFIS . read ()) != - 1 ) { s_temp = s_temp + Character . toString (( char ) i_character ); } myFIS . close (); Externer Speicher Diese Speicherl\u00f6sung dient zum Ablegen von Daten auf dem externen Speicher des Ger\u00e4ts, die standardm\u00e4\u00dfig \u201c \u00f6ffentlich \u201d zug\u00e4nglich sind, d.h. eine fremde App hat vollen Zugriff auf diese Daten und ein Benutzer kann die Daten \u00e4ndern. Dabei wird allgemein zwischen folgenden beiden externen Speichern unterschieden: Externer Speicher, der entfernt werden kann (z.B. MicroSD-Karte) Externer Speicher, der im Ger\u00e4t selbst vorhanden ist und sich somit nicht entfernen l\u00e4sst Die Daten auf dem externen Speicher werden dauerhaft gespeichert und selbst dann noch behalten, wenn die App gel\u00f6scht wird. Einsatzzweck Diese Speicherl\u00f6sung ist ideal f\u00fcr Dateien, die keine Zugriffsbeschr\u00e4nkungen ben\u00f6tigen auch anderen Apps zur Verf\u00fcgung stehen sollen der Benutzer auch mit seinem Computer erreichen k\u00f6nnen soll Berechtigungen Um vom bzw. in den externen Speicher zu lesen oder zu schreiben, musst du die folgenden Berechtigungen in die Manifest-Datei oberhalb des Application -Attributs schreiben: Lesen und Schreiben: <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /> Nur zum Lesen: <uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" /> \u00dcberpr\u00fcfung, ob externes Medium vorhanden ist Ein externes Speichermedium kann m\u00f6glicherweise nicht verf\u00fcgbar sein, z.B. weil der Benutzer die SD-Karte entfernt hat. Deswegen solltest du vor dem Zugriff immer \u00fcberpr\u00fcfen, ob das Medium verf\u00fcgbar ist. Dazu fr\u00e4gst du den Zustand des externen Speichers ab, indem du die Methode getExternalStorageState() aufrufst und \u00fcberpr\u00fcfst, ob der zur\u00fcckgegebene Zustand gleich MEDIA_MOUNTED ist. Beispiel: 1 2 3 4 5 6 7 public boolean isExternalStorageWritable () { String s_zustand = Environment . getExternalStorageState (); if ( Environment . MEDIA_MOUNTED . equals ( s_zustand )) { return true ; } return false ; } Schreiben der Daten Bevor du Daten in den externen Speicher schreibst, musst du dir \u00fcberlegen, ob du diese in ein \u00f6ffentliches oder ein privates Verzeichnis ablegen m\u00f6chtest. Du besorgst dir also erstmal den Zugriff auf eines der beiden Verzeichnisse \u00fcber die folgenden Methoden: getExternalStoragePublicDirectory() Mit dieser Methode bekommst du Zugriff auf ein \u00f6ffentliches externes Speicherverzeichnis. In Android gibt es beispielsweise folgende \u00f6ffentliche externe Verzeichnisse: DIRECTORY_ALARMS DIRECTORY_DCIM DIRECTORY_DOCUMENTS DIRECTORY_DOWNLOADS Sobald du den Zugriff auf eines der obigen Verzeichnisse hast, erstellst du eine Datei mittels des File-Konstruktors und \u00fcbergibst diesem sowohl das Verzeichnis, als auch den Dateinamen. Beispiel: 1 2 3 File myFolder = Environment . getExternalStoragePublicDirectory ( Environment . DIRECTORY_DOCUMENTS ); File myFile = new File ( myFolder , \"beispieldatei.txt\" ); getExternalFilesDir() Diese Methode erm\u00f6glicht den Zugriff auf ein privates externes Speicherverzeichnis. Lesen der Daten Um Daten aus dem externen Speicher zu lesen, stehen dir die gleichen Methoden wie beim Schreiben zur Verf\u00fcgung: getExternalStoragePublicDirectory() getExternalFilesDir() Wie du auf diese Methoden verwenden kannst, wurde bereits im Abschnitt \u201cSchreiben der Daten\u201d erkl\u00e4rt und deswegen an dieser Stelle nicht erneut erkl\u00e4rt. Danach rufst du die Methode openFileInput() auf und \u00fcbergibst dieser Methode den Dateinamen. Als R\u00fcckgabewert bekommst du ein FileInputStream -Objekt, welches du zur weiteren Verwendung ben\u00f6tigst. Anschlie\u00dfend liest du mittels der read() -Methode die Daten aus und schlie\u00dft den Datenstrom am Ende mit close() . Beispiel: 1 2 3 4 5 6 7 FileInputStream myFIS = openFileInput ( \"dateiname.txt\" ); int i_read = - 1 ; StringBuffer sb_puffer = new StringBuffer (); while ( read = myFIS . read ()) != - 1 ) { sb_puffer . append (( char ) read ); } myFIS . close (); SQLite-Datenbank Bei SQLite handelt es sich um eine abgespeckte und bereits in Android integrierte relationale Datenbank zur Speicherung strukturierter und \u201c privater \u201d Daten (z.B. Kontakte). Bei SQLite wird f\u00fcr den Zugriff die Datenbank-Abfragesprache SQL verwendet und alle Daten werden auf dem Ger\u00e4t im Verzeichnis data/data/package_name/databases abgelegt. Wenn du eine SQLite-Datenbank verwendest, laufen alle Interaktionen mit der Datenbank \u00fcber eine Instanz der Klasse SQLiteOpenHelper , die deine SQL-Anfragen ausf\u00fchrt und die Datenbank f\u00fcr dich verwaltet. Einsatzzweck Diese Speicherl\u00f6sung ist ideal f\u00fcr sich wiederholende und strukturierte Daten. Shared Preferences Bei dieser Speicherl\u00f6sung werden primitive Daten als Schl\u00fcssel-Wert-Paare in einer XML-Datei im Ger\u00e4te-Verzeichnis data/data/package_name/shared-prefs abgelegt. Die Daten bleiben w\u00e4hrend der gesamten Benutzersitzung erhalten und sind selbst dann noch vorhanden, wenn die App von Android beendet wurde. Es k\u00f6nnen dabei folgende primitive Datentypen gespeichert werden: boolean (true, false) float (12.4f, 2.9f,\u2026) long (325l, \u2026) int (3, 6, 2, \u2026) String (Name, Stra\u00dfe,\u2026) Set<String> Einsatzzweck Diese Speicherl\u00f6sung ist ideal f\u00fcr Daten, die \u00fcber mehrere Benutzer-Sitzungen hinweg gespeichert werden sollen, wie z.B. Benutzer-Einstellungen oder der Punktestand in einem Spiel. Erstellung einer SharedPreference-Datei Um eine SharedPreference-Datei anzulegen, musst du eine der folgenden Methode verwenden: getSharedPreferences ( String s_name , int mode ) Diese Methode verwendest du, wenn du mehrere SharedPreference-Dateien ben\u00f6tigst. Dieser Methode \u00fcbergibst du als ersten Parameter den Namen zur Datei-Unterscheidung und als zweiten Parameter den Modus. Hier gibt es zwar mehrere Modi, aber Android empfiehlt aus Sicherheitsgr\u00fcnden nur noch den MODE_PRIVATE zu verwenden. getPreferences ( int mode ) Diese Methode verwendest du, wenn du nur eine SharedPreference-Datei ben\u00f6tigst. Hier musst du lediglich den Modus als einzigen Parameter \u00fcbergeben, da du ja keinen Namen zur Datei-Unterscheidung brauchst. Daten in SharedPreference schreiben Die Daten werden folgenderma\u00dfen in eine SharedPreference-Datei geschrieben: Erzeuge eine Referenz auf ein SharedPreference-Objekt mittels der folgenden Methoden: getSharedPreference() getPreference() Rufe den SharedPreference-Editor auf, um die SharedPreference-Datei bearbeiten zu k\u00f6nnen F\u00fcge mit diesem Editor und einer der putXXX() -Methoden, wie z.B. putString() Daten in die SharedPreference-Datei ein Best\u00e4tige das Hinzuf\u00fcgen der Daten mittels der commit() - oder apply() -Methode Beispiel: 1 2 3 4 5 6 7 8 public static final String s_sharedPref = \"myPrefsName\" ; mySharedPreferences = getSharedPreferences ( s_sharedPref , 0 ); //0 = MODE_PRIVATE SharedPreference . Editor myEditor = mySharedPreferences . edit (); myEditor . putString ( \"CurrentChannel\" , \"ARD\" ); //CurrentChannel = Schl\u00fcssel und ARD = Wert myEditor . apply (); Daten aus SharedPreference auslesen Die Daten f\u00fcr SharedPreferences werden folgenderma\u00dfen ausgelesen: Erzeuge eine Referenz auf ein SharedPreference-Objekt mittels der folgenden Methoden: getSharedPreference() getPreference() Verwende den \u201cSchl\u00fcssel\u201d f\u00fcr denjenigen Wert, den du auslesen m\u00f6chtest Verwende die zum Datentyp passende Methode zum Auslesen der Daten (z.B. getInt() , getLong() , \u2026) Note Info : Der zweite Parameter der getXXX() -Methode sollte ein Ersatzwert sein, falls kein aktueller Wert zu ermitteln ist (z.B. weil es keinen Schl\u00fcssel mit dem angegebenen Namen gibt) Beispiel: 1 2 3 SharedPreferences mySharedPreferences = getSharedPreferences ( s_sharedPref , 0 ); String s_name = mySharedPreferences . getString ( \"Name\" , \"\" ); What you have Learned Abstract After having finished this lession, you know\u2026 \u2026how to store private or public data in Android \u2026how the different storage strategies work and how you use them \u2026how to implement a specific strategy based on the use case at hand. Disclaimer Most of the information in this lecture has been compiled from the following sources: https://www.big-app.de/daten-speicher-in-android/","title":"Data Storage"},{"location":"data_storage/#daten-speicherung-in-android","text":"Last Updated: 2019-06-04 Abstract Lernziele Sie kennen die verschiedenen M\u00f6glichkeiten, wie sich Daten unter Android persistent speichern lassen Sie kennen die Vor- und Nachteile der verschiedenen Speicherm\u00f6glichkeiten Sie k\u00f6nnen die hier vorgestellten Speichermechanismen in einer Android App implementieren bzw. f\u00fcr einen konkreten Anwendungsfall einsetzen Note Hinweis : Die hier vorgestellten Informationen stammen aus der hervorragenden Zusammenschrift der Seite https://www.big-app.de/daten-speicher-in-android/ Update : Nachstehend finden sich die Beispiele zur Speicherung von Zust\u00e4nden von UI-Elementen aus der Vorlesung: Speicherung von Zustandsinformationen im internen Speicher des Ger\u00e4tes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 private boolean saveState () { try { DataOutputStream dos = new DataOutputStream ( openFileOutput ( FILENAME , MODE_PRIVATE )); dos . writeInt ( sekVolume . getProgress ()); dos . flush (); dos . close (); lblMessage . append ( \"\\n\\nState successfully stored...\" ); return true ; } catch ( FileNotFoundException e ) { lblMessage . setText ( e . getMessage ()); e . printStackTrace (); } catch ( IOException e ) { lblMessage . setText ( e . getMessage ()); e . printStackTrace (); } return false ; } Laden von Zustandsinformationen aus dem internen Speicher: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 private boolean loadState () { try { DataInputStream dis = new DataInputStream ( openFileInput ( FILENAME )); int volume = dis . readInt (); if ( volume > lowerBound && volume < upperBound ) { sekVolume . setProgress ( volume ); } dis . close (); lblMessage . append ( \"\\nState successfully loaded...\" ); return true ; } catch ( IOException e ) { lblMessage . setText ( e . getMessage ()); e . printStackTrace (); } return false ; } Laden von Zustandsinformationen beim Erzeugen der Activity in onCreate() : 1 2 3 4 5 6 File file = new File ( getApplicationContext (). getFilesDir (), FILENAME ); if ( file . exists ()) { loadState (); } else { lblMessage . append ( \"\\n\\nFile not found...\" ); }","title":"Daten-Speicherung in Android"},{"location":"data_storage/#welche-daten-speicher-gibt-es-in-android","text":"F\u00fcr die Speicherung persistenter Daten bietet Android mehrere L\u00f6sungen an, die von den Bed\u00fcrfnissen und W\u00fcnschen des Android-Entwicklers abh\u00e4ngig sind. So gibt es mehrere Daten-Speicher , die die Daten entweder privat ablegen oder f\u00fcr andere Apps bzw. Benutzer \u00f6ffentlich zur Verf\u00fcgung stellen. Zudem ist die Wahl der Speicherl\u00f6sung davon abh\u00e4ngig, wieviel Speicherplatz die Daten ben\u00f6tigen und auf welche Weise die Daten gespeichert werden sollen. Man unterscheidet allgemein zwischen folgenden Speicherl\u00f6sungen: Speicher-L\u00f6sungen in Android (auf dem Ger\u00e4t) : Interner / Externer Speicher SQLite-Datenbank SharedPreferences Content Provider Speicher-L\u00f6sungen au\u00dferhalb von Android (au\u00dferhalb des Ger\u00e4ts): Netzwerkspeicher Firebase Cloud etc. Note Info : In diesem Artikel wird lediglich ein \u00dcberblick zu den verschiedenen Speicherl\u00f6sungen in Android gegeben und nicht zu sehr ins Detail gegangen. Zudem geht der Artikel nicht auf die Speicherl\u00f6sungen au\u00dferhalb von Android ein.","title":"Welche Daten-Speicher gibt es in Android?"},{"location":"data_storage/#interner-speicher","text":"Bei dieser Speicherl\u00f6sung werden Daten standardm\u00e4\u00dfig als \u201c privat \u201d im internen Speicher des Ger\u00e4ts abgelegt, d.h. eine fremde App hat keinen Zugriff auf diese Daten. Die Daten werden auch nur solange im internen Speicher gehalten, bis der Benutzer die App vom Ger\u00e4t entfernt. Im internen Speicher k\u00f6nnen dabei z.B. folgende Dateien abgespeichert werden: Texte Bilder Videos Lieder Diese Dateien werden auf dem Ger\u00e4t im Verzeichnis data/data/package_name/files abgelegt und sind permanent vorhanden. Eine App hat zudem immer eine Schreib- und Lese-Berechtigung f\u00fcr den internen Speicher und es muss somit keine entsprechende Berechtigung in die Manifest-Datei eingetragen werden. Es gibt auf dem Ger\u00e4t zwei unterschiedliche Verzeichnisse , die sich nach der Speicherart unterscheiden: Permanenter Speicher : F\u00fcr dauerhafte Daten, die \u00fcber getFilesDir() erreichbar sind Tempor\u00e4rer Speicher : F\u00fcr Cache-Daten, die \u00fcber getCacheDir() erreichbar sind","title":"Interner Speicher"},{"location":"data_storage/#einsatzzweck","text":"Diese Speicherl\u00f6sung ist ideal, wenn du sicher sein m\u00f6chtest, dass weder der Benutzer noch andere Apps auf deine Dateien zugreifen k\u00f6nnen sollen.","title":"Einsatzzweck"},{"location":"data_storage/#schreiben-der-daten","text":"Um Daten in den internen Speicher schreiben zu k\u00f6nnen, rufst du die Methode openFileOutput() mit dem Namen der Datei und dem Modus auf. Als Modus kannst du, je nach Verwendungszweck, die folgenden beiden Modi verwenden: MODE_PRIVATE : Es wird eine private Datei erstellt, d.h. nur die eigenen App hat Zugriff darauf MODE_APPEND : Wenn eine Datei bereits existiert, dann werden Daten ans Datei-Ende geschrieben Die Methode openFileOutput() gibt eine Instanz von FileOutputStream zur\u00fcck, mit der du dann die Methode write() aufrufen kannst, um in die Datei schreiben zu k\u00f6nnen. Am Schluss schlie\u00dft du den Datenstrom mit der close() -Methode. Beispiel: 1 2 3 4 5 String s_text = \"Beispieltext\" ; FileOutputStream myFOS = openFileOutput ( \"dateiname.txt\" , MODE_PRIVATE ); myFOS . write ( s_text . getBytes ()); myFOS . close ();","title":"Schreiben der Daten"},{"location":"data_storage/#lesen-der-daten","text":"Um aus der soeben erstellten Datei lesen zu k\u00f6nnen, rufst du die Methode openFileInput() mit dem Namen der Datei auf und bekommst als R\u00fcckgabewert eine Instanz von FileInputStream zur\u00fcck. Danach rufst du mit dieser Instanz die read() -Methode auf, um aus der Datei byteweise zu lesen. Am Ende schlie\u00dft du den Datenstrom wieder \u00fcber die close() -Methode. Beispiel: 1 2 3 4 5 6 7 FileInputStream myFIS = openFileInput ( \"dateiname.txt\" ); int i_character ; String s_temp = \"\" ; while ( ( i_character = myFIS . read ()) != - 1 ) { s_temp = s_temp + Character . toString (( char ) i_character ); } myFIS . close ();","title":"Lesen der Daten:"},{"location":"data_storage/#externer-speicher","text":"Diese Speicherl\u00f6sung dient zum Ablegen von Daten auf dem externen Speicher des Ger\u00e4ts, die standardm\u00e4\u00dfig \u201c \u00f6ffentlich \u201d zug\u00e4nglich sind, d.h. eine fremde App hat vollen Zugriff auf diese Daten und ein Benutzer kann die Daten \u00e4ndern. Dabei wird allgemein zwischen folgenden beiden externen Speichern unterschieden: Externer Speicher, der entfernt werden kann (z.B. MicroSD-Karte) Externer Speicher, der im Ger\u00e4t selbst vorhanden ist und sich somit nicht entfernen l\u00e4sst Die Daten auf dem externen Speicher werden dauerhaft gespeichert und selbst dann noch behalten, wenn die App gel\u00f6scht wird.","title":"Externer Speicher"},{"location":"data_storage/#einsatzzweck_1","text":"Diese Speicherl\u00f6sung ist ideal f\u00fcr Dateien, die keine Zugriffsbeschr\u00e4nkungen ben\u00f6tigen auch anderen Apps zur Verf\u00fcgung stehen sollen der Benutzer auch mit seinem Computer erreichen k\u00f6nnen soll","title":"Einsatzzweck"},{"location":"data_storage/#berechtigungen","text":"Um vom bzw. in den externen Speicher zu lesen oder zu schreiben, musst du die folgenden Berechtigungen in die Manifest-Datei oberhalb des Application -Attributs schreiben: Lesen und Schreiben: <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /> Nur zum Lesen: <uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" />","title":"Berechtigungen"},{"location":"data_storage/#uberprufung-ob-externes-medium-vorhanden-ist","text":"Ein externes Speichermedium kann m\u00f6glicherweise nicht verf\u00fcgbar sein, z.B. weil der Benutzer die SD-Karte entfernt hat. Deswegen solltest du vor dem Zugriff immer \u00fcberpr\u00fcfen, ob das Medium verf\u00fcgbar ist. Dazu fr\u00e4gst du den Zustand des externen Speichers ab, indem du die Methode getExternalStorageState() aufrufst und \u00fcberpr\u00fcfst, ob der zur\u00fcckgegebene Zustand gleich MEDIA_MOUNTED ist. Beispiel: 1 2 3 4 5 6 7 public boolean isExternalStorageWritable () { String s_zustand = Environment . getExternalStorageState (); if ( Environment . MEDIA_MOUNTED . equals ( s_zustand )) { return true ; } return false ; }","title":"\u00dcberpr\u00fcfung, ob externes Medium vorhanden ist"},{"location":"data_storage/#schreiben-der-daten_1","text":"Bevor du Daten in den externen Speicher schreibst, musst du dir \u00fcberlegen, ob du diese in ein \u00f6ffentliches oder ein privates Verzeichnis ablegen m\u00f6chtest. Du besorgst dir also erstmal den Zugriff auf eines der beiden Verzeichnisse \u00fcber die folgenden Methoden: getExternalStoragePublicDirectory() Mit dieser Methode bekommst du Zugriff auf ein \u00f6ffentliches externes Speicherverzeichnis. In Android gibt es beispielsweise folgende \u00f6ffentliche externe Verzeichnisse: DIRECTORY_ALARMS DIRECTORY_DCIM DIRECTORY_DOCUMENTS DIRECTORY_DOWNLOADS Sobald du den Zugriff auf eines der obigen Verzeichnisse hast, erstellst du eine Datei mittels des File-Konstruktors und \u00fcbergibst diesem sowohl das Verzeichnis, als auch den Dateinamen. Beispiel: 1 2 3 File myFolder = Environment . getExternalStoragePublicDirectory ( Environment . DIRECTORY_DOCUMENTS ); File myFile = new File ( myFolder , \"beispieldatei.txt\" ); getExternalFilesDir() Diese Methode erm\u00f6glicht den Zugriff auf ein privates externes Speicherverzeichnis.","title":"Schreiben der Daten"},{"location":"data_storage/#lesen-der-daten_1","text":"Um Daten aus dem externen Speicher zu lesen, stehen dir die gleichen Methoden wie beim Schreiben zur Verf\u00fcgung: getExternalStoragePublicDirectory() getExternalFilesDir() Wie du auf diese Methoden verwenden kannst, wurde bereits im Abschnitt \u201cSchreiben der Daten\u201d erkl\u00e4rt und deswegen an dieser Stelle nicht erneut erkl\u00e4rt. Danach rufst du die Methode openFileInput() auf und \u00fcbergibst dieser Methode den Dateinamen. Als R\u00fcckgabewert bekommst du ein FileInputStream -Objekt, welches du zur weiteren Verwendung ben\u00f6tigst. Anschlie\u00dfend liest du mittels der read() -Methode die Daten aus und schlie\u00dft den Datenstrom am Ende mit close() . Beispiel: 1 2 3 4 5 6 7 FileInputStream myFIS = openFileInput ( \"dateiname.txt\" ); int i_read = - 1 ; StringBuffer sb_puffer = new StringBuffer (); while ( read = myFIS . read ()) != - 1 ) { sb_puffer . append (( char ) read ); } myFIS . close ();","title":"Lesen der Daten"},{"location":"data_storage/#sqlite-datenbank","text":"Bei SQLite handelt es sich um eine abgespeckte und bereits in Android integrierte relationale Datenbank zur Speicherung strukturierter und \u201c privater \u201d Daten (z.B. Kontakte). Bei SQLite wird f\u00fcr den Zugriff die Datenbank-Abfragesprache SQL verwendet und alle Daten werden auf dem Ger\u00e4t im Verzeichnis data/data/package_name/databases abgelegt. Wenn du eine SQLite-Datenbank verwendest, laufen alle Interaktionen mit der Datenbank \u00fcber eine Instanz der Klasse SQLiteOpenHelper , die deine SQL-Anfragen ausf\u00fchrt und die Datenbank f\u00fcr dich verwaltet.","title":"SQLite-Datenbank"},{"location":"data_storage/#einsatzzweck_2","text":"Diese Speicherl\u00f6sung ist ideal f\u00fcr sich wiederholende und strukturierte Daten.","title":"Einsatzzweck"},{"location":"data_storage/#shared-preferences","text":"Bei dieser Speicherl\u00f6sung werden primitive Daten als Schl\u00fcssel-Wert-Paare in einer XML-Datei im Ger\u00e4te-Verzeichnis data/data/package_name/shared-prefs abgelegt. Die Daten bleiben w\u00e4hrend der gesamten Benutzersitzung erhalten und sind selbst dann noch vorhanden, wenn die App von Android beendet wurde. Es k\u00f6nnen dabei folgende primitive Datentypen gespeichert werden: boolean (true, false) float (12.4f, 2.9f,\u2026) long (325l, \u2026) int (3, 6, 2, \u2026) String (Name, Stra\u00dfe,\u2026) Set<String>","title":"Shared Preferences"},{"location":"data_storage/#einsatzzweck_3","text":"Diese Speicherl\u00f6sung ist ideal f\u00fcr Daten, die \u00fcber mehrere Benutzer-Sitzungen hinweg gespeichert werden sollen, wie z.B. Benutzer-Einstellungen oder der Punktestand in einem Spiel.","title":"Einsatzzweck"},{"location":"data_storage/#erstellung-einer-sharedpreference-datei","text":"Um eine SharedPreference-Datei anzulegen, musst du eine der folgenden Methode verwenden: getSharedPreferences ( String s_name , int mode ) Diese Methode verwendest du, wenn du mehrere SharedPreference-Dateien ben\u00f6tigst. Dieser Methode \u00fcbergibst du als ersten Parameter den Namen zur Datei-Unterscheidung und als zweiten Parameter den Modus. Hier gibt es zwar mehrere Modi, aber Android empfiehlt aus Sicherheitsgr\u00fcnden nur noch den MODE_PRIVATE zu verwenden. getPreferences ( int mode ) Diese Methode verwendest du, wenn du nur eine SharedPreference-Datei ben\u00f6tigst. Hier musst du lediglich den Modus als einzigen Parameter \u00fcbergeben, da du ja keinen Namen zur Datei-Unterscheidung brauchst.","title":"Erstellung einer SharedPreference-Datei"},{"location":"data_storage/#daten-in-sharedpreference-schreiben","text":"Die Daten werden folgenderma\u00dfen in eine SharedPreference-Datei geschrieben: Erzeuge eine Referenz auf ein SharedPreference-Objekt mittels der folgenden Methoden: getSharedPreference() getPreference() Rufe den SharedPreference-Editor auf, um die SharedPreference-Datei bearbeiten zu k\u00f6nnen F\u00fcge mit diesem Editor und einer der putXXX() -Methoden, wie z.B. putString() Daten in die SharedPreference-Datei ein Best\u00e4tige das Hinzuf\u00fcgen der Daten mittels der commit() - oder apply() -Methode Beispiel: 1 2 3 4 5 6 7 8 public static final String s_sharedPref = \"myPrefsName\" ; mySharedPreferences = getSharedPreferences ( s_sharedPref , 0 ); //0 = MODE_PRIVATE SharedPreference . Editor myEditor = mySharedPreferences . edit (); myEditor . putString ( \"CurrentChannel\" , \"ARD\" ); //CurrentChannel = Schl\u00fcssel und ARD = Wert myEditor . apply ();","title":"Daten in SharedPreference schreiben"},{"location":"data_storage/#daten-aus-sharedpreference-auslesen","text":"Die Daten f\u00fcr SharedPreferences werden folgenderma\u00dfen ausgelesen: Erzeuge eine Referenz auf ein SharedPreference-Objekt mittels der folgenden Methoden: getSharedPreference() getPreference() Verwende den \u201cSchl\u00fcssel\u201d f\u00fcr denjenigen Wert, den du auslesen m\u00f6chtest Verwende die zum Datentyp passende Methode zum Auslesen der Daten (z.B. getInt() , getLong() , \u2026) Note Info : Der zweite Parameter der getXXX() -Methode sollte ein Ersatzwert sein, falls kein aktueller Wert zu ermitteln ist (z.B. weil es keinen Schl\u00fcssel mit dem angegebenen Namen gibt) Beispiel: 1 2 3 SharedPreferences mySharedPreferences = getSharedPreferences ( s_sharedPref , 0 ); String s_name = mySharedPreferences . getString ( \"Name\" , \"\" );","title":"Daten aus SharedPreference auslesen"},{"location":"data_storage/#what-you-have-learned","text":"Abstract After having finished this lession, you know\u2026 \u2026how to store private or public data in Android \u2026how the different storage strategies work and how you use them \u2026how to implement a specific strategy based on the use case at hand.","title":"What you have Learned"},{"location":"data_storage/#disclaimer","text":"Most of the information in this lecture has been compiled from the following sources: https://www.big-app.de/daten-speicher-in-android/","title":"Disclaimer"},{"location":"generics/","text":"Generics (=Typisierte Collections) Warning Generics : Generics ist ein Java-Sprachmittel das es erlaubt, Klassen und Methoden mit Typparametern zu parametrisieren um trotz generischer Programmierung Typsicherheit zu gew\u00e4hrleisten. Generics werden nur w\u00e4hrend der Kompilierung ausgewertet. Eigenschaften Eine wichtige Eigenschaft von Java ist, dass der Compiler die Typen pr\u00fcft und so wei\u00df, welche Eigenschaften vorhanden sind und welche nicht. Hier unterscheidet sich Java von dynamischen Programmiersprachen wie Python oder PHP, die erst sp\u00e4t eine Pr\u00fcfung zur Laufzeit vornehmen. Beispiele Zugriff auf ein Listenelement ohne Generics : 1 2 3 List meineListe = new ArrayList (); meineListe . add ( \"Hallo\" ); String s = ( String ) meineListe . get ( 0 ); Wie im obigen Beispiel zu sehen ist, ist ein Typecasting notwendig, um das entspr. Element aus der Collection ( ArrayList ) auszulesen. Weiters k\u00f6nnen Fehler durch inkompatible Typen erst zur Laufzeit erkannt werden; mit Generics bereits w\u00e4hrend der Kompilierung (=Umwandlung von Java-Code in Bytecode). Umsetzung des obigen Beispiels mit Generics : 1 2 3 List < String > meineListe = new ArrayList < String > (); meineListe . add ( \"Hallo\" ); String s = meineListe . get ( 0 ); Die Variante mit Generics ben\u00f6tigt beim Lesen keinen Typecast. Eine Mischung aus Code mit und ohne Generics sollte nach M\u00f6glichkeit vermieden werden, da dies verwirrend sein kann und zu Fehlern f\u00fchren kann. Collections Die wichtigsten Collection-Klassen in der \u00dcbersicht ArrayList HashMap HashSet ArrayList 1 2 3 public class ArrayList extends AbstractList implements List , Cloneable , Serializable ArrayList realisiert eine lineare Liste als dynamisches Array . Wahlfreier Zugriff ist schneller als bei LinkedList, Einf\u00fcgen und L\u00f6schen dagegen langsamer. ArrayList ist besonders bei \u00fcberwiegend lesendem Zugriff oder bei kleinen Listen vorzuziehen. Wichtige Methoden 1 2 3 4 5 6 7 size () add () remove () contains () Iterator iterator () get () set () HashMap 1 2 3 public class HashMap extends AbstractMap implements Map , Cloneable , Serializable Wie Hashtable bietet HashMap einen assoziativen Speicher , der Paare von Schl\u00fcsseln und dazugeh\u00f6rigen Werten verwaltet. \u00dcber den Schl\u00fcssel ist ein Zugriff auf den Wert m\u00f6glich. Der Schl\u00fcssel kann als Name des Wertes interpretiert werden. Anders als Hashtable erlaubt HashMap das Einf\u00fcgen von null-Werten und ist nicht synchronisiert. HashMap bietet nicht direkt einen Iterator. Dieser kann jedoch leicht \u00fcber keySet() , values() oder entrySet() gebildet werden (z.B. Iterator = HashMap . entrySet (). iterator () ). Wichtige Methoden 1 2 3 4 5 6 7 8 size () get () put () containsKey () containsValue () Set keySet () Collection values () Set entrySet () HashSet 1 2 3 public class HashSet extends AbstractSet implements Set , Cloneable , Serializable HashSet realisiert eine doublettenlose ungeordnete Menge von Elementen, auf die mit Mengenoperationen zugegriffen werden kann. Die Iterationsreihenfolge ist ungeordnet und muss nicht reproduzierbar sein. Wichtige Methoden 1 2 3 4 5 size () add () remove () contains () Iterator iterator () Disclaimer Eine Vielzahl der hier wiedergegebenen Informationen stammt aus folgenden Quellen: https://www.torsten-horn.de/techdocs/java-generics.htm https://openbook.rheinwerk-verlag.de/javainsel9/javainsel_07_001.htm","title":"Collections und Generics"},{"location":"generics/#generics-typisierte-collections","text":"Warning Generics : Generics ist ein Java-Sprachmittel das es erlaubt, Klassen und Methoden mit Typparametern zu parametrisieren um trotz generischer Programmierung Typsicherheit zu gew\u00e4hrleisten. Generics werden nur w\u00e4hrend der Kompilierung ausgewertet.","title":"Generics (=Typisierte Collections)"},{"location":"generics/#eigenschaften","text":"Eine wichtige Eigenschaft von Java ist, dass der Compiler die Typen pr\u00fcft und so wei\u00df, welche Eigenschaften vorhanden sind und welche nicht. Hier unterscheidet sich Java von dynamischen Programmiersprachen wie Python oder PHP, die erst sp\u00e4t eine Pr\u00fcfung zur Laufzeit vornehmen.","title":"Eigenschaften"},{"location":"generics/#beispiele","text":"Zugriff auf ein Listenelement ohne Generics : 1 2 3 List meineListe = new ArrayList (); meineListe . add ( \"Hallo\" ); String s = ( String ) meineListe . get ( 0 ); Wie im obigen Beispiel zu sehen ist, ist ein Typecasting notwendig, um das entspr. Element aus der Collection ( ArrayList ) auszulesen. Weiters k\u00f6nnen Fehler durch inkompatible Typen erst zur Laufzeit erkannt werden; mit Generics bereits w\u00e4hrend der Kompilierung (=Umwandlung von Java-Code in Bytecode). Umsetzung des obigen Beispiels mit Generics : 1 2 3 List < String > meineListe = new ArrayList < String > (); meineListe . add ( \"Hallo\" ); String s = meineListe . get ( 0 ); Die Variante mit Generics ben\u00f6tigt beim Lesen keinen Typecast. Eine Mischung aus Code mit und ohne Generics sollte nach M\u00f6glichkeit vermieden werden, da dies verwirrend sein kann und zu Fehlern f\u00fchren kann.","title":"Beispiele"},{"location":"generics/#collections","text":"Die wichtigsten Collection-Klassen in der \u00dcbersicht ArrayList HashMap HashSet","title":"Collections"},{"location":"generics/#arraylist","text":"1 2 3 public class ArrayList extends AbstractList implements List , Cloneable , Serializable ArrayList realisiert eine lineare Liste als dynamisches Array . Wahlfreier Zugriff ist schneller als bei LinkedList, Einf\u00fcgen und L\u00f6schen dagegen langsamer. ArrayList ist besonders bei \u00fcberwiegend lesendem Zugriff oder bei kleinen Listen vorzuziehen. Wichtige Methoden 1 2 3 4 5 6 7 size () add () remove () contains () Iterator iterator () get () set ()","title":"ArrayList"},{"location":"generics/#hashmap","text":"1 2 3 public class HashMap extends AbstractMap implements Map , Cloneable , Serializable Wie Hashtable bietet HashMap einen assoziativen Speicher , der Paare von Schl\u00fcsseln und dazugeh\u00f6rigen Werten verwaltet. \u00dcber den Schl\u00fcssel ist ein Zugriff auf den Wert m\u00f6glich. Der Schl\u00fcssel kann als Name des Wertes interpretiert werden. Anders als Hashtable erlaubt HashMap das Einf\u00fcgen von null-Werten und ist nicht synchronisiert. HashMap bietet nicht direkt einen Iterator. Dieser kann jedoch leicht \u00fcber keySet() , values() oder entrySet() gebildet werden (z.B. Iterator = HashMap . entrySet (). iterator () ). Wichtige Methoden 1 2 3 4 5 6 7 8 size () get () put () containsKey () containsValue () Set keySet () Collection values () Set entrySet ()","title":"HashMap"},{"location":"generics/#hashset","text":"1 2 3 public class HashSet extends AbstractSet implements Set , Cloneable , Serializable HashSet realisiert eine doublettenlose ungeordnete Menge von Elementen, auf die mit Mengenoperationen zugegriffen werden kann. Die Iterationsreihenfolge ist ungeordnet und muss nicht reproduzierbar sein. Wichtige Methoden 1 2 3 4 5 size () add () remove () contains () Iterator iterator () Disclaimer Eine Vielzahl der hier wiedergegebenen Informationen stammt aus folgenden Quellen: https://www.torsten-horn.de/techdocs/java-generics.htm https://openbook.rheinwerk-verlag.de/javainsel9/javainsel_07_001.htm","title":"HashSet"},{"location":"grundlagen/","text":"Grundlagen zur Android-Entwicklung mit Java und Android Studio Abstract Objectives Sie kennen die wesentlichen Bedienelemente des Layout Editors Sie ko\u0308nnen einfache Android Projekte mit Android Studio anlegen Sie k\u00f6nnen eine App auf einem physischen oder einem virtuellen Ger\u00e4t deployen Sie k\u00f6nnen ein virtuelles Device anlegen Sie kennen die wesentlichen UI-Elemente in Android The Layout Editor Android Studio provides the layout editor for quickly building an app\u2019s layout of user interface (UI) elements. It lets you drag elements to a visual design and blueprint view, position them in the layout, add constraints, and set attributes. Constraints determine the position of a UI element within the layout. A constraint represents a connection or alignment to another view, the parent layout, or an invisible guideline. Explore the layout editor, and refer to the figure below as you follow the numbered steps: In the app --> res --> layout folder in the Project --> Android pane, double-click the activity_main.xml file to open it, if it is not already open. Click the Design tab if it is not already selected. You use the Design tab to manipulate elements and the layout, and the Text tab to edit the XML code for the layout. The Palettes pane shows UI elements that you can use in your app\u2019s layout. The Component Tree pane shows the view hierarchy of UI elements. View elements are organized into a tree hierarchy of parents and children, in which a child inherits the attributes of its parent. In the figure above, the TextView is a child of the ConstraintLayout . The design and blueprint panes of the layout editor showing the UI elements in the layout. In the figure above, the layout shows only one element: a TextView that displays \"Hello World\" . The Attributes tab displays the Attributes pane for setting properties for a UI element. Create and Manage Virtual Devices Source: https://codelabs.developers.google.com/codelabs/android-training-hello-world/index.html?index=..%2F..%2Fandroid-training#4 Use the Android Virtual Device (AVD) manager to create a virtual device (also known as an emulator ) that simulates the configuration for a particular type of Android device, and use that virtual device to run an app. Using the AVD Manager , you define the hardware characteristics of a device, its API level, storage, skin, and other properties and save it as a virtual device . With virtual devices, you can test apps on different device configurations (such as tablets and phones) with different API levels, without having to use physical devices. An Android Virtual Device (AVD) is a configuration that defines the characteristics of an Android phone, tablet, Wear OS, or Android TV device that you want to simulate in the Android Emulator. The AVD Manager is an interface you can launch from Android Studio that helps you create and manage AVDs. The AVD Manager can be opend using Tools > AVD Manager or by clicking on the AVD Manager icon in the toolbar. Deploy an App on a Physical Device In order to deploy an App on a physical device, you must turn on USB Debugging on your Android device. This is enabled in the Developer options settings of your device. On Android 4.2 and higher, the Developer options screen is hidden by default. To show developer options and enable USB Debugging: On your device, open Settings , search for About phone , click on About phone , and tap Build number seven times . Return to the previous screen (Settings / System). Developer options appears in the list. Tap Developer options . Choose USB Debugging . Now you can connect your device and run the app from Android Studio. Connect your device to your development machine with a USB cable. Click the Run button in the toolbar. The Select Deployment Target window opens with the list of available emulators and connected devices. Select your device, and click OK . Android Studio installs and runs the app on your device. UIs in Android The user interface (UI) that appears on a screen of an Android device consists of a hierarchy of objects called views \u2014 every element of the screen is a View . The View class represents the basic building block for all UI components, and the base class for classes that provide interactive UI components such as buttons, checkboxes, and text entry fields. Commonly used View subclasses are: TextView for displaying text. EditText to enable the user to enter and edit text. Button and other clickable elements (such as RadioButton, CheckBox, and Spinner) to provide interactive behavior. ScrollView and RecyclerView to display scrollable items. ImageView for displaying images. ConstraintLayout and LinearLayout for containing other View elements and positioning them. The Java code that displays and drives the UI is contained in a class that extends Activity . An Activity is usually associated with a layout of UI views defined as an XML (eXtended Markup Language) file . This XML file is usually named after its Activity and defines the layout of View elements on the screen. Example For example, the MainActivity code in the Hello World app displays a layout defined in the activity_main.xml layout file. Marshalling und Unmarshalling Marshalling refers to the process of converting the data or the objects inbto a byte-stream, and unmarshalling is the reverse process of converting the byte-stream beack to their original data or object. The conversion is achieved through serialization . The purpose of the marshalling/unmarshalling process is to transfer data between remote systems or system components (eg. classes or activities). Note Definition: Unmarshalling or unmarshaling refers to the process of transforming a representation of an object that was used for storage or transmission to a representation of the object that is executable. A serialized object which was used for communication can not be processed by a computer program. An unmarshalling interface takes the serialized object and transforms it into an executable form. Unmarshalling (similar to deserialization) is the reverse process of marshalling. Other Tipps Integrating External Resources Integrate images into your android project using the newly introduced resource manager (\u2192 see https://stackoverflow.com/a/57330638 ).","title":"Grundlagen"},{"location":"grundlagen/#grundlagen-zur-android-entwicklung-mit-java-und-android-studio","text":"Abstract Objectives Sie kennen die wesentlichen Bedienelemente des Layout Editors Sie ko\u0308nnen einfache Android Projekte mit Android Studio anlegen Sie k\u00f6nnen eine App auf einem physischen oder einem virtuellen Ger\u00e4t deployen Sie k\u00f6nnen ein virtuelles Device anlegen Sie kennen die wesentlichen UI-Elemente in Android","title":"Grundlagen zur Android-Entwicklung mit Java und Android Studio"},{"location":"grundlagen/#the-layout-editor","text":"Android Studio provides the layout editor for quickly building an app\u2019s layout of user interface (UI) elements. It lets you drag elements to a visual design and blueprint view, position them in the layout, add constraints, and set attributes. Constraints determine the position of a UI element within the layout. A constraint represents a connection or alignment to another view, the parent layout, or an invisible guideline. Explore the layout editor, and refer to the figure below as you follow the numbered steps: In the app --> res --> layout folder in the Project --> Android pane, double-click the activity_main.xml file to open it, if it is not already open. Click the Design tab if it is not already selected. You use the Design tab to manipulate elements and the layout, and the Text tab to edit the XML code for the layout. The Palettes pane shows UI elements that you can use in your app\u2019s layout. The Component Tree pane shows the view hierarchy of UI elements. View elements are organized into a tree hierarchy of parents and children, in which a child inherits the attributes of its parent. In the figure above, the TextView is a child of the ConstraintLayout . The design and blueprint panes of the layout editor showing the UI elements in the layout. In the figure above, the layout shows only one element: a TextView that displays \"Hello World\" . The Attributes tab displays the Attributes pane for setting properties for a UI element.","title":"The Layout Editor"},{"location":"grundlagen/#create-and-manage-virtual-devices","text":"Source: https://codelabs.developers.google.com/codelabs/android-training-hello-world/index.html?index=..%2F..%2Fandroid-training#4 Use the Android Virtual Device (AVD) manager to create a virtual device (also known as an emulator ) that simulates the configuration for a particular type of Android device, and use that virtual device to run an app. Using the AVD Manager , you define the hardware characteristics of a device, its API level, storage, skin, and other properties and save it as a virtual device . With virtual devices, you can test apps on different device configurations (such as tablets and phones) with different API levels, without having to use physical devices. An Android Virtual Device (AVD) is a configuration that defines the characteristics of an Android phone, tablet, Wear OS, or Android TV device that you want to simulate in the Android Emulator. The AVD Manager is an interface you can launch from Android Studio that helps you create and manage AVDs. The AVD Manager can be opend using Tools > AVD Manager or by clicking on the AVD Manager icon in the toolbar.","title":"Create and Manage Virtual Devices"},{"location":"grundlagen/#deploy-an-app-on-a-physical-device","text":"In order to deploy an App on a physical device, you must turn on USB Debugging on your Android device. This is enabled in the Developer options settings of your device. On Android 4.2 and higher, the Developer options screen is hidden by default. To show developer options and enable USB Debugging: On your device, open Settings , search for About phone , click on About phone , and tap Build number seven times . Return to the previous screen (Settings / System). Developer options appears in the list. Tap Developer options . Choose USB Debugging . Now you can connect your device and run the app from Android Studio. Connect your device to your development machine with a USB cable. Click the Run button in the toolbar. The Select Deployment Target window opens with the list of available emulators and connected devices. Select your device, and click OK . Android Studio installs and runs the app on your device.","title":"Deploy an App on a Physical Device"},{"location":"grundlagen/#uis-in-android","text":"The user interface (UI) that appears on a screen of an Android device consists of a hierarchy of objects called views \u2014 every element of the screen is a View . The View class represents the basic building block for all UI components, and the base class for classes that provide interactive UI components such as buttons, checkboxes, and text entry fields. Commonly used View subclasses are: TextView for displaying text. EditText to enable the user to enter and edit text. Button and other clickable elements (such as RadioButton, CheckBox, and Spinner) to provide interactive behavior. ScrollView and RecyclerView to display scrollable items. ImageView for displaying images. ConstraintLayout and LinearLayout for containing other View elements and positioning them. The Java code that displays and drives the UI is contained in a class that extends Activity . An Activity is usually associated with a layout of UI views defined as an XML (eXtended Markup Language) file . This XML file is usually named after its Activity and defines the layout of View elements on the screen. Example For example, the MainActivity code in the Hello World app displays a layout defined in the activity_main.xml layout file.","title":"UIs in Android"},{"location":"grundlagen/#marshalling-und-unmarshalling","text":"Marshalling refers to the process of converting the data or the objects inbto a byte-stream, and unmarshalling is the reverse process of converting the byte-stream beack to their original data or object. The conversion is achieved through serialization . The purpose of the marshalling/unmarshalling process is to transfer data between remote systems or system components (eg. classes or activities). Note Definition: Unmarshalling or unmarshaling refers to the process of transforming a representation of an object that was used for storage or transmission to a representation of the object that is executable. A serialized object which was used for communication can not be processed by a computer program. An unmarshalling interface takes the serialized object and transforms it into an executable form. Unmarshalling (similar to deserialization) is the reverse process of marshalling.","title":"Marshalling und Unmarshalling"},{"location":"grundlagen/#other-tipps","text":"","title":"Other Tipps"},{"location":"grundlagen/#integrating-external-resources","text":"Integrate images into your android project using the newly introduced resource manager (\u2192 see https://stackoverflow.com/a/57330638 ).","title":"Integrating External Resources"},{"location":"handler/","text":"Handling UI-Events Abstract Objectives You are familiar with the concepts of handlers You can implement a handler to receive messages from background threads Handlers for UI Interactions Since Android employs an event-driven processing model, it uses the concept of handlers to react to user input and user interactions. Handlers can be defined on three different ways Design Pane OnClick handler can be specified in Android Studio in the onClick field in the Design tab\u2019s Attributes pane; there you can enter the name of the method that is to be executed when an onclick event is captured on the widget. XML Editor You can also specify the name of the handler method in the XML editor by adding the android:onClick property to the widget. Activity Class You can define the handler logic in the programming code using the { component }. setOn ... Listener ( new View . On ...) { ... } methods and implementing the respective interfaces as anonymous inner classes. A click handler is a method that is invoked when the user clicks or taps on a clickable UI element. Handlers as Message Queues For more information see https://stackoverflow.com/questions/13840007/what-exactly-does-the-post-method-do Background threads and AsyncTasks run in parallel to the UI Thread and are invoked asynchronosly. It is forbidden for such threads to access or modify components created on the UI Thread. Therefore, they need to communicate their information in an asynchronous way using a message queue , which needs to be passed from the invoking activity as a reference during their instantiation. The message queue allows background threads to publish messages in the form of message objects , consisting of key and data values. The invoking activity needs to define a message handler for the message queue that will be invoked by the system whenever a new message object is published by a background thread to the message queue. Based on the message key , the message handler can then decide about how to process the receiving message. A handler receives messages from background threads and updates views on the UI thread (Source: stackoverflow.com )","title":"Handler"},{"location":"handler/#handling-ui-events","text":"Abstract Objectives You are familiar with the concepts of handlers You can implement a handler to receive messages from background threads","title":"Handling UI-Events"},{"location":"handler/#handlers-for-ui-interactions","text":"Since Android employs an event-driven processing model, it uses the concept of handlers to react to user input and user interactions. Handlers can be defined on three different ways Design Pane OnClick handler can be specified in Android Studio in the onClick field in the Design tab\u2019s Attributes pane; there you can enter the name of the method that is to be executed when an onclick event is captured on the widget. XML Editor You can also specify the name of the handler method in the XML editor by adding the android:onClick property to the widget. Activity Class You can define the handler logic in the programming code using the { component }. setOn ... Listener ( new View . On ...) { ... } methods and implementing the respective interfaces as anonymous inner classes. A click handler is a method that is invoked when the user clicks or taps on a clickable UI element.","title":"Handlers for UI Interactions"},{"location":"handler/#handlers-as-message-queues","text":"For more information see https://stackoverflow.com/questions/13840007/what-exactly-does-the-post-method-do Background threads and AsyncTasks run in parallel to the UI Thread and are invoked asynchronosly. It is forbidden for such threads to access or modify components created on the UI Thread. Therefore, they need to communicate their information in an asynchronous way using a message queue , which needs to be passed from the invoking activity as a reference during their instantiation. The message queue allows background threads to publish messages in the form of message objects , consisting of key and data values. The invoking activity needs to define a message handler for the message queue that will be invoked by the system whenever a new message object is published by a background thread to the message queue. Based on the message key , the message handler can then decide about how to process the receiving message. A handler receives messages from background threads and updates views on the UI thread (Source: stackoverflow.com )","title":"Handlers as Message Queues"},{"location":"json/","text":"JavaScript Object Notation (JSON) Abstract Lernziele Sie kennen die Grundstruktur von JSON Daten Sie kennen einige der bekanntesten JSON Bibliotheken unter Android Sie k\u00f6nnen JSON-Daten unter Android mittels entspr. Bibliotheken verarbeiten Android JSON Library The Android platform includes the standard json.org library, which allows processing and creating JSON files. Warning Plase note: Instances of the json.org class are not thread safe . Although this class is nonfinal, it was not designed for inheritance and should not be subclassed. In particular, self-use by overrideable methods is not specified. Note Hint: You can also use open source libraries such as Gson and Moshi for JSON processing. These libraries are easier to use, in general faster and provide more flexibility. JSONObject The JSONObject class provides a modifiable set of name/value mappings. Names are unique, non-null strings. Values may be any mix of JSONObjects , JSONArrays , Strings, Booleans, Integers, Longs, Doubles or NULL. Values may not be null , NaNs, infinities, or of any type not listed here. Note Hinweis: F\u00fcr das Praktikum ist die Verwendung von JSONObject ausreichend, da die Antworten des TV-Servers vordefiniert und einfach zu verarbeiten sind. F\u00fcr komplexere Applikationen empfiehlt sich die Verwendung der eingangs genannten Bibliotheken. Storing Data as JSON Writing JSON is very simple. Just create the JSONObject or JSONArray and use the .put() method. 1 2 3 4 5 6 7 8 9 10 11 12 public void writeJSON () { JSONObject object = new JSONObject (); try { object . put ( \"name\" , \"Jack Hack\" ); object . put ( \"score\" , new Integer ( 200 )); object . put ( \"current\" , new Double ( 152.32 )); object . put ( \"nickname\" , \"Hacker\" ); } catch ( JSONException e ) { e . printStackTrace (); } System . out . println ( object ); } Reading Data from the JSONObject Converting a JSON string into a JSON object is also very simple. The following code demonstrates how to transform a JSON string into a JSONObject from which further data can be extracted. 1 2 3 4 5 6 7 8 9 10 import org.json.JSONArray ; import org.json.JSONObject ; String jsonString = readJsonObjectFromSomeWhere (); try { JSONObject json = new JSONObject ( jsonString ); } catch ( Exception e ) { e . printStackTrace (); } // read data from the JSONObject Note Note: The structure of the serialized JSON data need to be known beforehand, i.e., the logic needed to map the extracted JSON elements into Java object must be implemented by hand in the source code. Warning Warning: The code example cannot run in the main thread in Android ( think about why ). Place such code in a separate Thread or use an AsyncTask . GSON Gson is a Java library that can be used to convert Java Objects into their JSON representation. It can also be used to convert a JSON string to an equivalent Java object. Gson can work with arbitrary Java objects including pre-existing objects that you do not have source code of. Using GSON The primary class to use is Gson , which you can just create by calling new Gson() . There is also a class GsonBuilder available that can be used to create a Gson instance with various settings like version control and so on. The Gson instance does not maintain any state while invoking Json operations. So, you are free to reuse the same object for multiple Json serialization and deserialization operations. Using Gson with Gradle/Android 1 2 3 dependencies { compile 'com.google.code.gson:gson:2.8.5' } Examples Converting Simple Datatypes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Serialization Gson gson = new Gson (); gson . toJson ( 1 ); // ==> 1 gson . toJson ( \"abcd\" ); // ==> \"abcd\" gson . toJson ( new Long ( 10 )); // ==> 10 int [] values = { 1 }; gson . toJson ( values ); // ==> [1] // Deserialization int one = gson . fromJson ( \"1\" , int . class ); Integer one = gson . fromJson ( \"1\" , Integer . class ); Long one = gson . fromJson ( \"1\" , Long . class ); Boolean false = gson . fromJson ( \"false\" , Boolean . class ); String str = gson . fromJson ( \"\\\"abc\\\"\" , String . class ); String [] anotherStr = gson . fromJson ( \"[\\\"abc\\\"]\" , String [] . class ); Converting Java Objects to JSON 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class BagOfPrimitives { private int value1 = 1 ; private String value2 = \"abc\" ; private transient int value3 = 3 ; BagOfPrimitives () { // no-args constructor } } // Serialization BagOfPrimitives obj = new BagOfPrimitives (); Gson gson = new Gson (); String json = gson . toJson ( obj ); // ==> json is {\"value1\":1,\"value2\":\"abc\"} Note Note It is not possible to serialize objects with circular references since that will result in infinite recursion. 1 2 3 // Deserialization BagOfPrimitives obj2 = gson . fromJson ( json , BagOfPrimitives . class ); // ==> obj2 is just like obj Important Remarks It is perfectly fine (and recommended) to use private fields. There is no need to use any annotations to indicate a field is to be included for serialization and deserialization. All fields in the current class (and from all super classes) are included by default. If a field is marked transient , (by default) it is ignored and not included in the JSON serialization or deserialization. This implementation handles nulls correctly. While serializing, a null field is omitted from the output. While deserializing, a missing entry in JSON results in setting the corresponding field in the object to its default value: null \u2192 for object types, zero \u2192 for numeric types, and false \u2192 for booleans. If a field is synthetic , it is ignored and not included in JSON serialization or deserialization. Fields corresponding to the outer classes in inner classes, anonymous classes, and local classes are ignored and not included in serialization or deserialization. Note TODO : Add more information about serializing and deserializing objects and collections (see gson user guide) Disclaimer Most of the information in this section has been compiled from the following sources: http://www.vogella.com/tutorials/AndroidJSON/article.html http://www.vogella.com/tutorials/JavaLibrary-Gson/article.html https://github.com/google/gson/blob/master/UserGuide.md https://developer.android.com/reference/org/json/JSONObject","title":"JSON"},{"location":"json/#javascript-object-notation-json","text":"Abstract Lernziele Sie kennen die Grundstruktur von JSON Daten Sie kennen einige der bekanntesten JSON Bibliotheken unter Android Sie k\u00f6nnen JSON-Daten unter Android mittels entspr. Bibliotheken verarbeiten","title":"JavaScript Object Notation (JSON)"},{"location":"json/#android-json-library","text":"The Android platform includes the standard json.org library, which allows processing and creating JSON files. Warning Plase note: Instances of the json.org class are not thread safe . Although this class is nonfinal, it was not designed for inheritance and should not be subclassed. In particular, self-use by overrideable methods is not specified. Note Hint: You can also use open source libraries such as Gson and Moshi for JSON processing. These libraries are easier to use, in general faster and provide more flexibility.","title":"Android JSON Library"},{"location":"json/#jsonobject","text":"The JSONObject class provides a modifiable set of name/value mappings. Names are unique, non-null strings. Values may be any mix of JSONObjects , JSONArrays , Strings, Booleans, Integers, Longs, Doubles or NULL. Values may not be null , NaNs, infinities, or of any type not listed here. Note Hinweis: F\u00fcr das Praktikum ist die Verwendung von JSONObject ausreichend, da die Antworten des TV-Servers vordefiniert und einfach zu verarbeiten sind. F\u00fcr komplexere Applikationen empfiehlt sich die Verwendung der eingangs genannten Bibliotheken.","title":"JSONObject"},{"location":"json/#storing-data-as-json","text":"Writing JSON is very simple. Just create the JSONObject or JSONArray and use the .put() method. 1 2 3 4 5 6 7 8 9 10 11 12 public void writeJSON () { JSONObject object = new JSONObject (); try { object . put ( \"name\" , \"Jack Hack\" ); object . put ( \"score\" , new Integer ( 200 )); object . put ( \"current\" , new Double ( 152.32 )); object . put ( \"nickname\" , \"Hacker\" ); } catch ( JSONException e ) { e . printStackTrace (); } System . out . println ( object ); }","title":"Storing Data as JSON"},{"location":"json/#reading-data-from-the-jsonobject","text":"Converting a JSON string into a JSON object is also very simple. The following code demonstrates how to transform a JSON string into a JSONObject from which further data can be extracted. 1 2 3 4 5 6 7 8 9 10 import org.json.JSONArray ; import org.json.JSONObject ; String jsonString = readJsonObjectFromSomeWhere (); try { JSONObject json = new JSONObject ( jsonString ); } catch ( Exception e ) { e . printStackTrace (); } // read data from the JSONObject Note Note: The structure of the serialized JSON data need to be known beforehand, i.e., the logic needed to map the extracted JSON elements into Java object must be implemented by hand in the source code. Warning Warning: The code example cannot run in the main thread in Android ( think about why ). Place such code in a separate Thread or use an AsyncTask .","title":"Reading Data from the JSONObject"},{"location":"json/#gson","text":"Gson is a Java library that can be used to convert Java Objects into their JSON representation. It can also be used to convert a JSON string to an equivalent Java object. Gson can work with arbitrary Java objects including pre-existing objects that you do not have source code of.","title":"GSON"},{"location":"json/#using-gson","text":"The primary class to use is Gson , which you can just create by calling new Gson() . There is also a class GsonBuilder available that can be used to create a Gson instance with various settings like version control and so on. The Gson instance does not maintain any state while invoking Json operations. So, you are free to reuse the same object for multiple Json serialization and deserialization operations.","title":"Using GSON"},{"location":"json/#using-gson-with-gradleandroid","text":"1 2 3 dependencies { compile 'com.google.code.gson:gson:2.8.5' }","title":"Using Gson with Gradle/Android"},{"location":"json/#examples","text":"","title":"Examples"},{"location":"json/#converting-simple-datatypes","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Serialization Gson gson = new Gson (); gson . toJson ( 1 ); // ==> 1 gson . toJson ( \"abcd\" ); // ==> \"abcd\" gson . toJson ( new Long ( 10 )); // ==> 10 int [] values = { 1 }; gson . toJson ( values ); // ==> [1] // Deserialization int one = gson . fromJson ( \"1\" , int . class ); Integer one = gson . fromJson ( \"1\" , Integer . class ); Long one = gson . fromJson ( \"1\" , Long . class ); Boolean false = gson . fromJson ( \"false\" , Boolean . class ); String str = gson . fromJson ( \"\\\"abc\\\"\" , String . class ); String [] anotherStr = gson . fromJson ( \"[\\\"abc\\\"]\" , String [] . class );","title":"Converting Simple Datatypes"},{"location":"json/#converting-java-objects-to-json","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class BagOfPrimitives { private int value1 = 1 ; private String value2 = \"abc\" ; private transient int value3 = 3 ; BagOfPrimitives () { // no-args constructor } } // Serialization BagOfPrimitives obj = new BagOfPrimitives (); Gson gson = new Gson (); String json = gson . toJson ( obj ); // ==> json is {\"value1\":1,\"value2\":\"abc\"} Note Note It is not possible to serialize objects with circular references since that will result in infinite recursion. 1 2 3 // Deserialization BagOfPrimitives obj2 = gson . fromJson ( json , BagOfPrimitives . class ); // ==> obj2 is just like obj","title":"Converting Java Objects to JSON"},{"location":"json/#important-remarks","text":"It is perfectly fine (and recommended) to use private fields. There is no need to use any annotations to indicate a field is to be included for serialization and deserialization. All fields in the current class (and from all super classes) are included by default. If a field is marked transient , (by default) it is ignored and not included in the JSON serialization or deserialization. This implementation handles nulls correctly. While serializing, a null field is omitted from the output. While deserializing, a missing entry in JSON results in setting the corresponding field in the object to its default value: null \u2192 for object types, zero \u2192 for numeric types, and false \u2192 for booleans. If a field is synthetic , it is ignored and not included in JSON serialization or deserialization. Fields corresponding to the outer classes in inner classes, anonymous classes, and local classes are ignored and not included in serialization or deserialization. Note TODO : Add more information about serializing and deserializing objects and collections (see gson user guide)","title":"Important Remarks"},{"location":"json/#disclaimer","text":"Most of the information in this section has been compiled from the following sources: http://www.vogella.com/tutorials/AndroidJSON/article.html http://www.vogella.com/tutorials/JavaLibrary-Gson/article.html https://github.com/google/gson/blob/master/UserGuide.md https://developer.android.com/reference/org/json/JSONObject","title":"Disclaimer"},{"location":"recycler_view/","text":"The RecyclerView Last Updated: 2020-01-21 Abstract Objectives You know how to use the RecyclerView class to display items in a scrollable list You know how to dynamically add items to the RecyclerView as they become visible through scrolling You know how to perform an action when the user taps a specific item Introduction A common feature in mobile apps is the display and manipulation of similar data items in form of lists or cards. Android favours the separation of rendering data items from their actual model data and therefore deploys the concept of adapters to link the display of data items (the View in the MVC-Pattern) to their actual data (the Model in the MVC-Pattern). The RecyclerView is a new ViewGroup that is prepared to render any adapter-based view in a similar and more resource-efficient way. It is the successor of ListView and GridView, and it can be found in the latest support-v7 version . One of the reasons is that RecyclerView has a more extensible framework , especially since it provides the ability to implement both horizontal and vertical layouts. Use the RecyclerView widget when you have data collections whose elements change at runtime based on user action or network events. A list being displayed using the RecyclerView (Source: Google ) RecyclerView Overview The RecyclerView widget is a more advanced, flexible, and resource-efficient version of ListView . In the RecyclerView model, several different components work together to display data. The overall container for the user interface is a RecyclerView object that you add to your layout. The RecyclerView fills itself with views provided by a layout manager that you provide. You can use one of the standard layout managers (such as LinearLayoutManager or GridLayoutManager ), or implement your own. The views in the list are represented by view holder objects . These objects are instances of a self-defined class that extends RecyclerView . ViewHolder (\u2192 link) . Each view holder is in charge of displaying a single item with a view. For example, if your list shows music collections, each view holder might represent a single album. The RecyclerView creates only as many view holders as are needed to display the on-screen portion of the dynamic content, plus a few extra. As the user scrolls through the list, the RecyclerView takes the off-screen views and rebinds them to the data which is scrolling onto the screen. The view holder objects are managed by an adapter , which is created by extending RecyclerView . Adapter (\u2192 link) . The adapter creates view holders as needed. binds the view holders to their data . It does this by assigning the view holder to a position , and calling the adapter\u2019s onBindViewHolder () method. That method uses the view holder\u2019s position to determine what the contents should be , based on its list position. Components In order to use a RecyclerView, the following components are needed: A data model containing the data to display by the RecyclerView . Adapter subclass. A RecyclerView for the scrolling list that contains the list items. A layout for one item of data. List items usually exhibit the same layout. A layout manager . RecyclerView . LayoutManager handles the hierarchy and layout of view elements. RecyclerView requires an explicit layout manager to manage the arrangement of list items contained within it. This layout could be vertical, horizontal, or a grid. An adapter that subclasses RecyclerView . Adapter and connects your data to the RecyclerView . It prepares the data in a RecyclerView . ViewHolder . A ViewHolder . A RecyclerView . ViewHolder ( Link ) is created inside the adapter and contains the view information for displaying one item by inflating the predefined item\u2019s layout. A recyclerview-selection library to select items in a RecyclerView list using touch or mouse input. (\u2192 this is not part of this documentation. ) Note Note : The selection library allows for the implementation of more advanced interaction features; it is not part of this documentation. Instead, we describe the selection of items using an onClickListener implemented in the RecyclerView . ViewHolder class. Glossary of Terms Adapter : A subclass of RecyclerView . Adapter responsible for providing views that represent items in a data set. Position : The position of a data item within an Adapter. Index : The index of an attached child view as used in a call to getChildAt ( int ) . Contrast with Position. Binding : The process of preparing a child view to display data corresponding to a position within the adapter. Recycle (view) : A view previously used to display data for a specific adapter position may be placed in a cache for later reuse to display the same type of data again later. This can drastically improve performance by skipping initial layout inflation or construction. Scrap (view) : A child view that has entered into a temporarily detached state during layout. Scrap views may be reused without becoming fully detached from the parent RecyclerView, either unmodified if no rebinding is required or modified by the adapter if the view was considered dirty. Dirty (view) : A child view that must be rebound by the adapter before being displayed. Using the RecyclerView Using a RecyclerView involves the following key steps: Add RecyclerView support library to the Gradle build file Define a model class to use as the data source Add a RecyclerView to your activity to display the items Create a custom row layout XML file to visualize the items Create a RecyclerView.Adapter and ViewHolder to render the items Bind the adapter to the data source to populate the RecyclerView Adding the RecyclerView Support Library Make sure the RecyclerView support library is listed as a dependency in the app/build.gradle file: 1 2 3 4 dependencies { ... implementation 'com.android.support:recyclerview-v7:27.1.1' } Click on Sync Project with Gradle files to let the IDE download the appropriate resources. Defining a Model Every RecyclerView is backed by a data source (the Model in the MVC-Paradigm). Therefore, a class which represents the data model being displayed by the RecyclerView needs to be defined explicitly. The following code excerpt shows an example data model for representing course ratings: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 public class Rating implements Serializable { public static final String TAG = Rating . class . getSimpleName (); private String date ; private int score ; public Rating () { this . date = generateDate (); this . score = generateScore (); } public Rating ( int score ) { this . date = generateDate (); this . score = score ; } public String generateDate () { this . date = new SimpleDateFormat ( \"E, dd. MMM yyyy, HH:mm\" ) . format ( new Date ( System . currentTimeMillis () - Math . round (( Math . random () * 31000000000.0 )))); return this . date ; } public int generateScore () { return ( int )( Math . round ( Math . random () * 4.0 ) + 1 ); } public String getDate () { return this . date ; } public void setDate ( String date ) { this . date = date ; } public void setScore ( int score ) { this . score = score ; } public int getScore () { return this . score ; } } Add the RecyclerView to the Activity\u2019s Layout Inside the desired activity layout XML file in res/layout/activity_users.xml , let\u2019s add the RecyclerView from the support library: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 <?xml version=\"1.0\" encoding=\"utf-8\"?> <android.support.constraint.ConstraintLayout xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:app= \"http://schemas.android.com/apk/res-auto\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" > <android.support.v7.widget.RecyclerView android:id= \"@+id/__set_id__\" android:layout_width= \"0dp\" android:layout_height= \"0dp\" app:layout_constraintBottom_toBottomOf= \"parent\" app:layout_constraintEnd_toEndOf= \"parent\" app:layout_constraintStart_toStartOf= \"parent\" app:layout_constraintTop_toTopOf= \"parent\" /> </android.support.constraint.ConstraintLayout> Create a Custom Item Layout Before we create the adapter, we need to define the XML layout file that will be used for each row within the list. The item layout contains the widgets used to represent the data of one item per row. The following listing displays an excerpt from the layout specification of a rating list item: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <?xml version=\"1.0\" encoding=\"utf-8\"?> <android.support.constraint.ConstraintLayout xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:app= \"http://schemas.android.com/apk/res-auto\" xmlns:tools= \"http://schemas.android.com/tools\" android:background= \"?android:attr/selectableItemBackground\" android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" > <TextView android:id= \"@+id/txtNumber\" android:layout_width= \"24dp\" android:layout_height= \"wrap_content\" android:layout_marginTop= \"8dp\" android:fontFamily= \"sans-serif-condensed-light\" android:gravity= \"right\" android:text= \"1.\" android:textSize= \"10sp\" app:layout_constraintBaseline_toBaselineOf= \"@id/txtDate\" app:layout_constraintBottom_toBottomOf= \"@+id/txtDate\" app:layout_constraintStart_toStartOf= \"parent\" app:layout_constraintTop_toTopOf= \"parent\" /> ... Note Note : Use wrap_content for the layout_height because RecyclerView versions prior to 23.2.1 previously ignored layout parameters ( Source ). Creating the RecyclerView . Adapter Here we need to create the adapter which will actually populate the data into the RecyclerView . The adapter\u2019s role is to convert an object at a position into a list row item to be inserted. The following things need to be implemented by the RecyclerView . Adapter : A ViewHolder that extends the ViewHolder class of the RecyclerView A container that holds the items to be displayed (representing the data model) A constructor to populate the container holding the items to be displayed Individual implementation (= overriding ) of the three RecycleView . Adapter methods public ViewHolder onCreateViewHolder ( ViewGroup viewGroup , int viewType ) public void onBindViewHolder ( ViewHolder viewHolder , int position ) public int getItemCount () Creating the ViewHolder However, with a RecyclerView the adapter requires the existence of a ViewHolder object which describes and provides access to all the views within each item row. We can create the basic empty adapter and holder together in an RecycleView . Adapter class as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // Create the basic adapter extending from RecyclerView.Adapter // Note that we specify a custom ViewHolder that provides access to our views public class MyIndividualAdapter extends RecyclerView . Adapter < MyIndividualAdapter . ViewHolder > { // Provide a direct reference to each of the views within a data item // Used to cache the views within the item layout for fast access public class ViewHolder extends RecyclerView . ViewHolder { // The holder should contain a member variable // for any view that will be set as you render a row public TextView nameTextView ; public Button messageButton ; // We also create a constructor that accepts the entire item row // and does the view lookups to find each subview public ViewHolder ( View itemView ) { // Stores the itemView in a public final member variable that can // be used to access the context from any ViewHolder instance. super ( itemView ); nameTextView = ( TextView ) itemView . findViewById ( R . id . contact_name ); messageButton = ( Button ) itemView . findViewById ( R . id . message_button ); } } } Implementing the RecycleView . Adapter Methods Every adapter has three primary methods: public ViewHolder onCreateViewHolder ( ViewGroup viewGroup , int viewType ) This callback method inflates the item layout and creates the ViewHolder instance. public void onBindViewHolder ( ViewHolder viewHolder , int position ) This callback methods binds the view elements to the data model, i.e., it retrieves the data to be displayed in the UI elements from the model (=data source) and assigns it to the view elements defined by the ViewHolder. public int getItemCount () This mehtod is used to determine the number of individual items contained in the model (=data source). Those methods need to be implemented in order to have a fully working adapter. Example The following code demonstrates the implementation of the three primary RecycleView . Adapter methods for a ratings adapter of the RecyclerViewDemoApp: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 public class RatingsAdapter extends RecyclerView . Adapter < RatingsAdapter . ViewHolder > { // A collection for the storage of items to be displayed private ArrayList < Rating > mRatings = new ArrayList < Rating > (); // The ViewHolder implementation of the adapter public class ViewHolder extends RecyclerView . ViewHolder { public TextView txtNumber ; public TextView txtDate ; public TextView txtScore ; public TextView lblScore ; public ImageButton btnRemove ; // Inflation of view elements contained in the item's layout // ViewHolder holds event handlers for caching reasons public ViewHolder ( final View itemView ) { super ( itemView ); txtNumber = ( TextView ) itemView . findViewById ( R . id . txtNumber ); txtDate = ( TextView ) itemView . findViewById ( R . id . txtDate ); txtScore = ( TextView ) itemView . findViewById ( R . id . txtScore ); lblScore = ( TextView ) itemView . findViewById ( R . id . lblScore ); btnRemove = ( ImageButton ) itemView . findViewById ( R . id . btnRemove ); } } // The adapter holds a reference to the data source public RatingsAdapter ( ArrayList < Rating > ratings ) { this . mRatings = ratings ; } // Creates the ViewHolder instance and inflates the item layout @NonNull @Override public ViewHolder onCreateViewHolder ( @NonNull ViewGroup viewGroup , int viewType ) { Context context = viewGroup . getContext (); LayoutInflater inflater = LayoutInflater . from ( context ); View ratingView = inflater . inflate ( R . layout . rating_item , viewGroup , false ); ViewHolder viewHolder = new ViewHolder ( ratingView ); return viewHolder ; } // Binds the data model to the view items @Override public void onBindViewHolder ( @NonNull ViewHolder viewHolder , int position ) { Rating rating = mRatings . get ( position ); TextView txtNumber = viewHolder . txtNumber ; txtNumber . setText ( String . valueOf ( position + 1 )); TextView txtData = viewHolder . txtDate ; txtData . setText ( rating . getDate ()); TextView txtScore = viewHolder . txtScore ; txtScore . setText ( String . valueOf ( rating . getScore ())); TextView lblScore = viewHolder . lblScore ; } @Override public int getItemCount () { return mRatings . size (); } } Binding the Adapter to the RecyclerView The binding is implemented in the activity containing the RecycleView . It involves 5 steps : Initializing (and populating) the data source (=data model) Inflating the RecyclerView\u2019s layout Instantiating the adapter instance and passing the data source Linking the adapter to the RecycleView instance Setting a layout for the RecycleView instance The following example demonstrates each step: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class UserListActivity extends AppCompatActivity { ArrayList < Contact > contacts ; @Override protected void onCreate ( Bundle savedInstanceState ) { // ... // Lookup the recyclerview in activity layout RecyclerView rvContacts = ( RecyclerView ) findViewById ( R . id . rvContacts ); // Initialize contacts contacts = Contact . createContactsList ( 20 ); // Create adapter passing in the sample user data ContactsAdapter adapter = new ContactsAdapter ( contacts ); // Attach the adapter to the recyclerview to populate items rvContacts . setAdapter ( adapter ); // Set layout manager to position the items rvContacts . setLayoutManager ( new LinearLayoutManager ( this )); // That's all! } } Interacting with the RecyclerView Adding Data to the Data Source Warning Don\u2019t add or remove data via the adapter Unlike ListView , there is no way to add or remove items directly through the RecyclerView adapter. In order to add or remove data, you need to make changes to the data source directly and notify the adapter of any changes. The adapter therefore provides a set of notification methods for changes related to the data source: Method Description notifyItemChanged ( int pos ) Notify that item at the position has changed. notifyItemInserted ( int pos ) Notify that item reflected at the position has been newly inserted. notifyItemRemoved ( int pos ) Notify that items previously located at the position have been removed from the data set. notifyDataSetChanged () Notify that the dataset has changed. Use only as last resort. In case an item is added to the end of the list, use the following code: 1 2 3 4 // Add a new rating mRatings . add ( new Rating ()); // Notify the adapter that an item was inserted at last position adapter . notifyItemInserted ( mRatings . size () - 1 ); Every time we want to add or remove items from the RecyclerView, we will need to explicitly inform the adapter of the event. Unlike the ListView adapter, a RecyclerView adapter should not rely on notifyDataSetChanged () since the more granular actions should be used. The API Documentation provides more details. Example The following code excerpt defines an onClick() handler for a Floating Action Button that adds a new rating to the data source every time it is activated: 1 2 3 4 5 6 7 8 9 10 11 fabAdd = ( FloatingActionButton ) findViewById ( R . id . fabAdd ); fabAdd . setOnClickListener ( new View . OnClickListener () { @Override public void onClick ( View v ) { mRatings . add ( new Rating ()); adapter . notifyItemInserted ( mRatings . size () - 1 ); Toast . makeText ( v . getContext (), \"Rating added\" , Toast . LENGTH_SHORT ) . show (); recRatings . smoothScrollToPosition ( mRatings . size () - 1 ); } }); Removing Data from the Data Source In the RecyclerViewDemoApp, each item (row) has a remove button at the right end of its row; once the button is activated (= clicked ) the current item will be removed from the list and the data source. In contrast to the FAB for adding an entry, the application code for removing an item will be placed in the adapter, since the handler for the remove button is defined within the ViewHolder class. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public ViewHolder ( final View itemView ) { super ( itemView ); txtNumber = ( TextView ) itemView . findViewById ( R . id . txtNumber ); txtDate = ( TextView ) itemView . findViewById ( R . id . txtDate ); txtScore = ( TextView ) itemView . findViewById ( R . id . txtScore ); lblScore = ( TextView ) itemView . findViewById ( R . id . lblScore ); btnRemove = ( ImageButton ) itemView . findViewById ( R . id . btnRemove ); btnRemove . setOnClickListener ( new View . OnClickListener () { @Override public void onClick ( View v ) { int pos = getAdapterPosition (); if ( pos != RecyclerView . NO_POSITION ) { Toast . makeText ( itemView . getContext (), \"Deleting Item #\" + ( pos + 1 ), Toast . LENGTH_SHORT ). show (); mRatings . remove ( pos ); notifyItemRemoved ( pos ); } }); } Warning Don\u2019t Forget to Fire the Notification Event! Although the code is defined in the adapter\u2019s ViewHolder implementation, please do not forget to fire the notification event for the adapter. Selecting Elements from the RecyclerView Note Note : This is a very simple form of implementing an onClickListener for a RecyclerView. At Link #1 and Link #2 you will find more advanced implementations of selection listener that provide more extensive sets of interaction features such as movement gestures or combining app bar actions with RecyclerView actions. However, the subsequently presented implementation is sufficient for this course. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public ViewHolder ( final View itemView ) { super ( itemView ); txtNumber = ( TextView ) itemView . findViewById ( R . id . txtNumber ); txtDate = ( TextView ) itemView . findViewById ( R . id . txtDate ); txtScore = ( TextView ) itemView . findViewById ( R . id . txtScore ); lblScore = ( TextView ) itemView . findViewById ( R . id . lblScore ); btnRemove = ( ImageButton ) itemView . findViewById ( R . id . btnRemove ); btnRemove . setOnClickListener ( new View . OnClickListener () { ... }); itemView . setOnClickListener ( new View . OnClickListener () { @Override public void onClick ( View v ) { int position = getAdapterPosition (); if ( position != RecyclerView . NO_POSITION ) { Toast . makeText ( v . getContext (), \"Item selected #\" + ( position + 1 ), Toast . LENGTH_SHORT ). show (); } } }); } Swipe Actions Consult this Link if you want to add swipe gestures to a RecyclerView. What you have Learned Abstract After having finished this lession, you know\u2026 \u2026how to setup a RecyclerView and a RecyclerView\u2019s Adapter \u2026how to implement the main elements of a RecyclerView \u2026how you can interact with a RecyclerView\u2019s elements (=items) Disclaimer Most of the information in this lecture has been compiled from the following sources: https://developer.android.com/guide/topics/ui/layout/recyclerview https://guides.codepath.com/android/using-the-recyclerview https://developer.android.com/reference/android/support/v7/widget/RecyclerView.html https://codelabs.developers.google.com/codelabs/android-training-create-recycler-view/index.html","title":"RecyclerView"},{"location":"recycler_view/#the-recyclerview","text":"Last Updated: 2020-01-21 Abstract Objectives You know how to use the RecyclerView class to display items in a scrollable list You know how to dynamically add items to the RecyclerView as they become visible through scrolling You know how to perform an action when the user taps a specific item","title":"The RecyclerView"},{"location":"recycler_view/#introduction","text":"A common feature in mobile apps is the display and manipulation of similar data items in form of lists or cards. Android favours the separation of rendering data items from their actual model data and therefore deploys the concept of adapters to link the display of data items (the View in the MVC-Pattern) to their actual data (the Model in the MVC-Pattern). The RecyclerView is a new ViewGroup that is prepared to render any adapter-based view in a similar and more resource-efficient way. It is the successor of ListView and GridView, and it can be found in the latest support-v7 version . One of the reasons is that RecyclerView has a more extensible framework , especially since it provides the ability to implement both horizontal and vertical layouts. Use the RecyclerView widget when you have data collections whose elements change at runtime based on user action or network events. A list being displayed using the RecyclerView (Source: Google )","title":"Introduction"},{"location":"recycler_view/#recyclerview-overview","text":"The RecyclerView widget is a more advanced, flexible, and resource-efficient version of ListView . In the RecyclerView model, several different components work together to display data. The overall container for the user interface is a RecyclerView object that you add to your layout. The RecyclerView fills itself with views provided by a layout manager that you provide. You can use one of the standard layout managers (such as LinearLayoutManager or GridLayoutManager ), or implement your own. The views in the list are represented by view holder objects . These objects are instances of a self-defined class that extends RecyclerView . ViewHolder (\u2192 link) . Each view holder is in charge of displaying a single item with a view. For example, if your list shows music collections, each view holder might represent a single album. The RecyclerView creates only as many view holders as are needed to display the on-screen portion of the dynamic content, plus a few extra. As the user scrolls through the list, the RecyclerView takes the off-screen views and rebinds them to the data which is scrolling onto the screen. The view holder objects are managed by an adapter , which is created by extending RecyclerView . Adapter (\u2192 link) . The adapter creates view holders as needed. binds the view holders to their data . It does this by assigning the view holder to a position , and calling the adapter\u2019s onBindViewHolder () method. That method uses the view holder\u2019s position to determine what the contents should be , based on its list position.","title":"RecyclerView Overview"},{"location":"recycler_view/#components","text":"In order to use a RecyclerView, the following components are needed: A data model containing the data to display by the RecyclerView . Adapter subclass. A RecyclerView for the scrolling list that contains the list items. A layout for one item of data. List items usually exhibit the same layout. A layout manager . RecyclerView . LayoutManager handles the hierarchy and layout of view elements. RecyclerView requires an explicit layout manager to manage the arrangement of list items contained within it. This layout could be vertical, horizontal, or a grid. An adapter that subclasses RecyclerView . Adapter and connects your data to the RecyclerView . It prepares the data in a RecyclerView . ViewHolder . A ViewHolder . A RecyclerView . ViewHolder ( Link ) is created inside the adapter and contains the view information for displaying one item by inflating the predefined item\u2019s layout. A recyclerview-selection library to select items in a RecyclerView list using touch or mouse input. (\u2192 this is not part of this documentation. ) Note Note : The selection library allows for the implementation of more advanced interaction features; it is not part of this documentation. Instead, we describe the selection of items using an onClickListener implemented in the RecyclerView . ViewHolder class.","title":"Components"},{"location":"recycler_view/#glossary-of-terms","text":"Adapter : A subclass of RecyclerView . Adapter responsible for providing views that represent items in a data set. Position : The position of a data item within an Adapter. Index : The index of an attached child view as used in a call to getChildAt ( int ) . Contrast with Position. Binding : The process of preparing a child view to display data corresponding to a position within the adapter. Recycle (view) : A view previously used to display data for a specific adapter position may be placed in a cache for later reuse to display the same type of data again later. This can drastically improve performance by skipping initial layout inflation or construction. Scrap (view) : A child view that has entered into a temporarily detached state during layout. Scrap views may be reused without becoming fully detached from the parent RecyclerView, either unmodified if no rebinding is required or modified by the adapter if the view was considered dirty. Dirty (view) : A child view that must be rebound by the adapter before being displayed.","title":"Glossary of Terms"},{"location":"recycler_view/#using-the-recyclerview","text":"Using a RecyclerView involves the following key steps: Add RecyclerView support library to the Gradle build file Define a model class to use as the data source Add a RecyclerView to your activity to display the items Create a custom row layout XML file to visualize the items Create a RecyclerView.Adapter and ViewHolder to render the items Bind the adapter to the data source to populate the RecyclerView","title":"Using the RecyclerView"},{"location":"recycler_view/#adding-the-recyclerview-support-library","text":"Make sure the RecyclerView support library is listed as a dependency in the app/build.gradle file: 1 2 3 4 dependencies { ... implementation 'com.android.support:recyclerview-v7:27.1.1' } Click on Sync Project with Gradle files to let the IDE download the appropriate resources.","title":"Adding the RecyclerView Support Library"},{"location":"recycler_view/#defining-a-model","text":"Every RecyclerView is backed by a data source (the Model in the MVC-Paradigm). Therefore, a class which represents the data model being displayed by the RecyclerView needs to be defined explicitly. The following code excerpt shows an example data model for representing course ratings: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 public class Rating implements Serializable { public static final String TAG = Rating . class . getSimpleName (); private String date ; private int score ; public Rating () { this . date = generateDate (); this . score = generateScore (); } public Rating ( int score ) { this . date = generateDate (); this . score = score ; } public String generateDate () { this . date = new SimpleDateFormat ( \"E, dd. MMM yyyy, HH:mm\" ) . format ( new Date ( System . currentTimeMillis () - Math . round (( Math . random () * 31000000000.0 )))); return this . date ; } public int generateScore () { return ( int )( Math . round ( Math . random () * 4.0 ) + 1 ); } public String getDate () { return this . date ; } public void setDate ( String date ) { this . date = date ; } public void setScore ( int score ) { this . score = score ; } public int getScore () { return this . score ; } }","title":"Defining a Model"},{"location":"recycler_view/#add-the-recyclerview-to-the-activitys-layout","text":"Inside the desired activity layout XML file in res/layout/activity_users.xml , let\u2019s add the RecyclerView from the support library: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 <?xml version=\"1.0\" encoding=\"utf-8\"?> <android.support.constraint.ConstraintLayout xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:app= \"http://schemas.android.com/apk/res-auto\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" > <android.support.v7.widget.RecyclerView android:id= \"@+id/__set_id__\" android:layout_width= \"0dp\" android:layout_height= \"0dp\" app:layout_constraintBottom_toBottomOf= \"parent\" app:layout_constraintEnd_toEndOf= \"parent\" app:layout_constraintStart_toStartOf= \"parent\" app:layout_constraintTop_toTopOf= \"parent\" /> </android.support.constraint.ConstraintLayout>","title":"Add the RecyclerView to the Activity's Layout"},{"location":"recycler_view/#create-a-custom-item-layout","text":"Before we create the adapter, we need to define the XML layout file that will be used for each row within the list. The item layout contains the widgets used to represent the data of one item per row. The following listing displays an excerpt from the layout specification of a rating list item: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <?xml version=\"1.0\" encoding=\"utf-8\"?> <android.support.constraint.ConstraintLayout xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:app= \"http://schemas.android.com/apk/res-auto\" xmlns:tools= \"http://schemas.android.com/tools\" android:background= \"?android:attr/selectableItemBackground\" android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" > <TextView android:id= \"@+id/txtNumber\" android:layout_width= \"24dp\" android:layout_height= \"wrap_content\" android:layout_marginTop= \"8dp\" android:fontFamily= \"sans-serif-condensed-light\" android:gravity= \"right\" android:text= \"1.\" android:textSize= \"10sp\" app:layout_constraintBaseline_toBaselineOf= \"@id/txtDate\" app:layout_constraintBottom_toBottomOf= \"@+id/txtDate\" app:layout_constraintStart_toStartOf= \"parent\" app:layout_constraintTop_toTopOf= \"parent\" /> ... Note Note : Use wrap_content for the layout_height because RecyclerView versions prior to 23.2.1 previously ignored layout parameters ( Source ).","title":"Create a Custom Item Layout"},{"location":"recycler_view/#creating-the-recyclerviewadapter","text":"Here we need to create the adapter which will actually populate the data into the RecyclerView . The adapter\u2019s role is to convert an object at a position into a list row item to be inserted. The following things need to be implemented by the RecyclerView . Adapter : A ViewHolder that extends the ViewHolder class of the RecyclerView A container that holds the items to be displayed (representing the data model) A constructor to populate the container holding the items to be displayed Individual implementation (= overriding ) of the three RecycleView . Adapter methods public ViewHolder onCreateViewHolder ( ViewGroup viewGroup , int viewType ) public void onBindViewHolder ( ViewHolder viewHolder , int position ) public int getItemCount ()","title":"Creating the RecyclerView.Adapter"},{"location":"recycler_view/#creating-the-viewholder","text":"However, with a RecyclerView the adapter requires the existence of a ViewHolder object which describes and provides access to all the views within each item row. We can create the basic empty adapter and holder together in an RecycleView . Adapter class as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // Create the basic adapter extending from RecyclerView.Adapter // Note that we specify a custom ViewHolder that provides access to our views public class MyIndividualAdapter extends RecyclerView . Adapter < MyIndividualAdapter . ViewHolder > { // Provide a direct reference to each of the views within a data item // Used to cache the views within the item layout for fast access public class ViewHolder extends RecyclerView . ViewHolder { // The holder should contain a member variable // for any view that will be set as you render a row public TextView nameTextView ; public Button messageButton ; // We also create a constructor that accepts the entire item row // and does the view lookups to find each subview public ViewHolder ( View itemView ) { // Stores the itemView in a public final member variable that can // be used to access the context from any ViewHolder instance. super ( itemView ); nameTextView = ( TextView ) itemView . findViewById ( R . id . contact_name ); messageButton = ( Button ) itemView . findViewById ( R . id . message_button ); } } }","title":"Creating the ViewHolder"},{"location":"recycler_view/#implementing-the-recycleviewadapter-methods","text":"Every adapter has three primary methods: public ViewHolder onCreateViewHolder ( ViewGroup viewGroup , int viewType ) This callback method inflates the item layout and creates the ViewHolder instance. public void onBindViewHolder ( ViewHolder viewHolder , int position ) This callback methods binds the view elements to the data model, i.e., it retrieves the data to be displayed in the UI elements from the model (=data source) and assigns it to the view elements defined by the ViewHolder. public int getItemCount () This mehtod is used to determine the number of individual items contained in the model (=data source). Those methods need to be implemented in order to have a fully working adapter.","title":"Implementing the RecycleView.Adapter Methods"},{"location":"recycler_view/#example","text":"The following code demonstrates the implementation of the three primary RecycleView . Adapter methods for a ratings adapter of the RecyclerViewDemoApp: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 public class RatingsAdapter extends RecyclerView . Adapter < RatingsAdapter . ViewHolder > { // A collection for the storage of items to be displayed private ArrayList < Rating > mRatings = new ArrayList < Rating > (); // The ViewHolder implementation of the adapter public class ViewHolder extends RecyclerView . ViewHolder { public TextView txtNumber ; public TextView txtDate ; public TextView txtScore ; public TextView lblScore ; public ImageButton btnRemove ; // Inflation of view elements contained in the item's layout // ViewHolder holds event handlers for caching reasons public ViewHolder ( final View itemView ) { super ( itemView ); txtNumber = ( TextView ) itemView . findViewById ( R . id . txtNumber ); txtDate = ( TextView ) itemView . findViewById ( R . id . txtDate ); txtScore = ( TextView ) itemView . findViewById ( R . id . txtScore ); lblScore = ( TextView ) itemView . findViewById ( R . id . lblScore ); btnRemove = ( ImageButton ) itemView . findViewById ( R . id . btnRemove ); } } // The adapter holds a reference to the data source public RatingsAdapter ( ArrayList < Rating > ratings ) { this . mRatings = ratings ; } // Creates the ViewHolder instance and inflates the item layout @NonNull @Override public ViewHolder onCreateViewHolder ( @NonNull ViewGroup viewGroup , int viewType ) { Context context = viewGroup . getContext (); LayoutInflater inflater = LayoutInflater . from ( context ); View ratingView = inflater . inflate ( R . layout . rating_item , viewGroup , false ); ViewHolder viewHolder = new ViewHolder ( ratingView ); return viewHolder ; } // Binds the data model to the view items @Override public void onBindViewHolder ( @NonNull ViewHolder viewHolder , int position ) { Rating rating = mRatings . get ( position ); TextView txtNumber = viewHolder . txtNumber ; txtNumber . setText ( String . valueOf ( position + 1 )); TextView txtData = viewHolder . txtDate ; txtData . setText ( rating . getDate ()); TextView txtScore = viewHolder . txtScore ; txtScore . setText ( String . valueOf ( rating . getScore ())); TextView lblScore = viewHolder . lblScore ; } @Override public int getItemCount () { return mRatings . size (); } }","title":"Example"},{"location":"recycler_view/#binding-the-adapter-to-the-recyclerview","text":"The binding is implemented in the activity containing the RecycleView . It involves 5 steps : Initializing (and populating) the data source (=data model) Inflating the RecyclerView\u2019s layout Instantiating the adapter instance and passing the data source Linking the adapter to the RecycleView instance Setting a layout for the RecycleView instance The following example demonstrates each step: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class UserListActivity extends AppCompatActivity { ArrayList < Contact > contacts ; @Override protected void onCreate ( Bundle savedInstanceState ) { // ... // Lookup the recyclerview in activity layout RecyclerView rvContacts = ( RecyclerView ) findViewById ( R . id . rvContacts ); // Initialize contacts contacts = Contact . createContactsList ( 20 ); // Create adapter passing in the sample user data ContactsAdapter adapter = new ContactsAdapter ( contacts ); // Attach the adapter to the recyclerview to populate items rvContacts . setAdapter ( adapter ); // Set layout manager to position the items rvContacts . setLayoutManager ( new LinearLayoutManager ( this )); // That's all! } }","title":"Binding the Adapter to the RecyclerView"},{"location":"recycler_view/#interacting-with-the-recyclerview","text":"","title":"Interacting with the RecyclerView"},{"location":"recycler_view/#adding-data-to-the-data-source","text":"Warning Don\u2019t add or remove data via the adapter Unlike ListView , there is no way to add or remove items directly through the RecyclerView adapter. In order to add or remove data, you need to make changes to the data source directly and notify the adapter of any changes. The adapter therefore provides a set of notification methods for changes related to the data source: Method Description notifyItemChanged ( int pos ) Notify that item at the position has changed. notifyItemInserted ( int pos ) Notify that item reflected at the position has been newly inserted. notifyItemRemoved ( int pos ) Notify that items previously located at the position have been removed from the data set. notifyDataSetChanged () Notify that the dataset has changed. Use only as last resort. In case an item is added to the end of the list, use the following code: 1 2 3 4 // Add a new rating mRatings . add ( new Rating ()); // Notify the adapter that an item was inserted at last position adapter . notifyItemInserted ( mRatings . size () - 1 ); Every time we want to add or remove items from the RecyclerView, we will need to explicitly inform the adapter of the event. Unlike the ListView adapter, a RecyclerView adapter should not rely on notifyDataSetChanged () since the more granular actions should be used. The API Documentation provides more details.","title":"Adding Data to the Data Source"},{"location":"recycler_view/#example_1","text":"The following code excerpt defines an onClick() handler for a Floating Action Button that adds a new rating to the data source every time it is activated: 1 2 3 4 5 6 7 8 9 10 11 fabAdd = ( FloatingActionButton ) findViewById ( R . id . fabAdd ); fabAdd . setOnClickListener ( new View . OnClickListener () { @Override public void onClick ( View v ) { mRatings . add ( new Rating ()); adapter . notifyItemInserted ( mRatings . size () - 1 ); Toast . makeText ( v . getContext (), \"Rating added\" , Toast . LENGTH_SHORT ) . show (); recRatings . smoothScrollToPosition ( mRatings . size () - 1 ); } });","title":"Example"},{"location":"recycler_view/#removing-data-from-the-data-source","text":"In the RecyclerViewDemoApp, each item (row) has a remove button at the right end of its row; once the button is activated (= clicked ) the current item will be removed from the list and the data source. In contrast to the FAB for adding an entry, the application code for removing an item will be placed in the adapter, since the handler for the remove button is defined within the ViewHolder class. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public ViewHolder ( final View itemView ) { super ( itemView ); txtNumber = ( TextView ) itemView . findViewById ( R . id . txtNumber ); txtDate = ( TextView ) itemView . findViewById ( R . id . txtDate ); txtScore = ( TextView ) itemView . findViewById ( R . id . txtScore ); lblScore = ( TextView ) itemView . findViewById ( R . id . lblScore ); btnRemove = ( ImageButton ) itemView . findViewById ( R . id . btnRemove ); btnRemove . setOnClickListener ( new View . OnClickListener () { @Override public void onClick ( View v ) { int pos = getAdapterPosition (); if ( pos != RecyclerView . NO_POSITION ) { Toast . makeText ( itemView . getContext (), \"Deleting Item #\" + ( pos + 1 ), Toast . LENGTH_SHORT ). show (); mRatings . remove ( pos ); notifyItemRemoved ( pos ); } }); } Warning Don\u2019t Forget to Fire the Notification Event! Although the code is defined in the adapter\u2019s ViewHolder implementation, please do not forget to fire the notification event for the adapter.","title":"Removing Data from the Data Source"},{"location":"recycler_view/#selecting-elements-from-the-recyclerview","text":"Note Note : This is a very simple form of implementing an onClickListener for a RecyclerView. At Link #1 and Link #2 you will find more advanced implementations of selection listener that provide more extensive sets of interaction features such as movement gestures or combining app bar actions with RecyclerView actions. However, the subsequently presented implementation is sufficient for this course. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public ViewHolder ( final View itemView ) { super ( itemView ); txtNumber = ( TextView ) itemView . findViewById ( R . id . txtNumber ); txtDate = ( TextView ) itemView . findViewById ( R . id . txtDate ); txtScore = ( TextView ) itemView . findViewById ( R . id . txtScore ); lblScore = ( TextView ) itemView . findViewById ( R . id . lblScore ); btnRemove = ( ImageButton ) itemView . findViewById ( R . id . btnRemove ); btnRemove . setOnClickListener ( new View . OnClickListener () { ... }); itemView . setOnClickListener ( new View . OnClickListener () { @Override public void onClick ( View v ) { int position = getAdapterPosition (); if ( position != RecyclerView . NO_POSITION ) { Toast . makeText ( v . getContext (), \"Item selected #\" + ( position + 1 ), Toast . LENGTH_SHORT ). show (); } } }); }","title":"Selecting Elements from the RecyclerView"},{"location":"recycler_view/#swipe-actions","text":"Consult this Link if you want to add swipe gestures to a RecyclerView.","title":"Swipe Actions"},{"location":"recycler_view/#what-you-have-learned","text":"Abstract After having finished this lession, you know\u2026 \u2026how to setup a RecyclerView and a RecyclerView\u2019s Adapter \u2026how to implement the main elements of a RecyclerView \u2026how you can interact with a RecyclerView\u2019s elements (=items)","title":"What you have Learned"},{"location":"recycler_view/#disclaimer","text":"Most of the information in this lecture has been compiled from the following sources: https://developer.android.com/guide/topics/ui/layout/recyclerview https://guides.codepath.com/android/using-the-recyclerview https://developer.android.com/reference/android/support/v7/widget/RecyclerView.html https://codelabs.developers.google.com/codelabs/android-training-create-recycler-view/index.html","title":"Disclaimer"},{"location":"serialisierung/","text":"Serialisierung und Input- / OutputStreams Auf dieser Seite finden Sie die Java-Beispiele zu Serialisierbarkeit von Objekten Input- und OutputStreams zur Speicherung von serialisierten Objekten Serialisierbarkeit Um Objekte in Java abspeichern zu k\u00f6nnen m\u00fcssen diese serialisiert werden. Hierzu muss das Interface Serializable implementiert und ein Wert f\u00fcr die statische Variable serialVersionUID vergeben werden. Anhand der vergebenen Wertes lassen sich verschiedene Klassenversionen bei der Serialisierung von Objekten unterscheiden. Die Datenmodellklasse in nachstehendem Beispiel implementiert das Serializable Interface und kann damit mittels einem OutputStream gespeichert (persistiert) und mittels einem InputStream geladen werden. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 package de.hda.nzse.examples.car ; import java.io.IOException ; import java.io.Serializable ; import java.util.Calendar ; public class Car implements Serializable { /** * Generated default serialized version UID */ private static final long serialVersionUID = 1L ; // Declaration of member variables private String typ = \"unknown\" ; private int power ; private int manufacturingDate ; // static class variable bound to class exclusively public static int exemplare = 0 ; // Constructor public Car ( String typ , int power , int manufacturingDate ) { super (); this . typ = typ ; this . power = power ; this . manufacturingDate = manufacturingDate ; exemplare += 1 ; } public String getTyp () { return typ ; } public void setTyp ( String typ ) { this . typ = typ ; } public int getPower () { return power ; } public void setPower ( int power ) { this . power = power ; } public int getManufacturingDate () { return manufacturingDate ; } public void setManufacturingDate ( int manufacturingDate ) { this . manufacturingDate = manufacturingDate ; } public int getAge () { return Calendar . getInstance (). get ( Calendar . YEAR ) - this . manufacturingDate ; } public void printInfo () { System . out . println ( \"Mein Auto ist ein \" + getTyp () + \" mit \" + getPower () + \" PS und ist \" + getAge () + \" Jahre alt.\" ); } } Laden und Speichern von serialisierten Objekten F\u00fcr das Laden und Speichern von Objekten werden Input- und OutputStreams ben\u00f6tigt: InputStreams \u2192 Laden von Daten OutputStreams \u2192 Speichern von Daten Je nach zu speicherndem Inhalt k\u00f6nnen unterschiedliche OutputStreams (bspw. DataOutputStream oder ObjectOutputStream ) verwendet werden. Diese m\u00fcssen f\u00fcr die Speicherung einen FileOutputStream kapseln, der den serialisierten Objektbytestrom empf\u00e4ngt und diesen dann auf das Filesystem schreibt. Im nachstehenden Beispiel ist dieser Prozess dargestellt: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 package de.hda.nzse.examples.car ; import java.io.FileInputStream ; import java.io.FileOutputStream ; import java.io.IOException ; import java.io.ObjectInputStream ; import java.io.ObjectOutputStream ; import java.util.ArrayList ; public class MyCarApp { public final static String STORAGE_LOCATION = \"/Users/stefan/Google Drive/hda/LVAs/NZSE/Java/resources/cars.txt\" ; public static void main ( String [] args ) { Car car1 = new Car ( \"Kombi\" , 177 , 2015 ); car1 . printInfo (); storeCar ( car1 ); Car car2 ; car2 = loadCar ( null ); // store data of car1 in car2 car2 . printInfo (); // prints identical data as car1 } /** * Method to store a single car instance in a file using serialization * @param car */ private static void storeCar ( Car car ) { try { FileOutputStream fileOut = new FileOutputStream ( STORAGE_LOCATION ); ObjectOutputStream out = new ObjectOutputStream ( fileOut ); out . writeObject ( car ); out . flush (); out . close (); fileOut . close (); System . out . println ( \"Serialized data is saved in \" + STORAGE_LOCATION ); } catch ( IOException i ) { i . printStackTrace (); } } /** * Java is always call-by-value * See http://www.javaschubla.de/2007/javaerst0200.html * @param car * @return */ private static Car loadCar ( Car car ) { Car temp = null ; try { FileInputStream fileIn = new FileInputStream ( STORAGE_LOCATION ); ObjectInputStream in = new ObjectInputStream ( fileIn ); temp = ( Car ) in . readObject (); in . close (); fileIn . close (); } catch ( IOException i ) { i . printStackTrace (); } catch ( ClassNotFoundException c ) { System . out . println ( \"Car class not found\" ); c . printStackTrace (); } return temp ; } }","title":"Serialisierung und Persistenz"},{"location":"serialisierung/#serialisierung-und-input-outputstreams","text":"Auf dieser Seite finden Sie die Java-Beispiele zu Serialisierbarkeit von Objekten Input- und OutputStreams zur Speicherung von serialisierten Objekten","title":"Serialisierung und Input- / OutputStreams"},{"location":"serialisierung/#serialisierbarkeit","text":"Um Objekte in Java abspeichern zu k\u00f6nnen m\u00fcssen diese serialisiert werden. Hierzu muss das Interface Serializable implementiert und ein Wert f\u00fcr die statische Variable serialVersionUID vergeben werden. Anhand der vergebenen Wertes lassen sich verschiedene Klassenversionen bei der Serialisierung von Objekten unterscheiden. Die Datenmodellklasse in nachstehendem Beispiel implementiert das Serializable Interface und kann damit mittels einem OutputStream gespeichert (persistiert) und mittels einem InputStream geladen werden. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 package de.hda.nzse.examples.car ; import java.io.IOException ; import java.io.Serializable ; import java.util.Calendar ; public class Car implements Serializable { /** * Generated default serialized version UID */ private static final long serialVersionUID = 1L ; // Declaration of member variables private String typ = \"unknown\" ; private int power ; private int manufacturingDate ; // static class variable bound to class exclusively public static int exemplare = 0 ; // Constructor public Car ( String typ , int power , int manufacturingDate ) { super (); this . typ = typ ; this . power = power ; this . manufacturingDate = manufacturingDate ; exemplare += 1 ; } public String getTyp () { return typ ; } public void setTyp ( String typ ) { this . typ = typ ; } public int getPower () { return power ; } public void setPower ( int power ) { this . power = power ; } public int getManufacturingDate () { return manufacturingDate ; } public void setManufacturingDate ( int manufacturingDate ) { this . manufacturingDate = manufacturingDate ; } public int getAge () { return Calendar . getInstance (). get ( Calendar . YEAR ) - this . manufacturingDate ; } public void printInfo () { System . out . println ( \"Mein Auto ist ein \" + getTyp () + \" mit \" + getPower () + \" PS und ist \" + getAge () + \" Jahre alt.\" ); } }","title":"Serialisierbarkeit"},{"location":"serialisierung/#laden-und-speichern-von-serialisierten-objekten","text":"F\u00fcr das Laden und Speichern von Objekten werden Input- und OutputStreams ben\u00f6tigt: InputStreams \u2192 Laden von Daten OutputStreams \u2192 Speichern von Daten Je nach zu speicherndem Inhalt k\u00f6nnen unterschiedliche OutputStreams (bspw. DataOutputStream oder ObjectOutputStream ) verwendet werden. Diese m\u00fcssen f\u00fcr die Speicherung einen FileOutputStream kapseln, der den serialisierten Objektbytestrom empf\u00e4ngt und diesen dann auf das Filesystem schreibt. Im nachstehenden Beispiel ist dieser Prozess dargestellt: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 package de.hda.nzse.examples.car ; import java.io.FileInputStream ; import java.io.FileOutputStream ; import java.io.IOException ; import java.io.ObjectInputStream ; import java.io.ObjectOutputStream ; import java.util.ArrayList ; public class MyCarApp { public final static String STORAGE_LOCATION = \"/Users/stefan/Google Drive/hda/LVAs/NZSE/Java/resources/cars.txt\" ; public static void main ( String [] args ) { Car car1 = new Car ( \"Kombi\" , 177 , 2015 ); car1 . printInfo (); storeCar ( car1 ); Car car2 ; car2 = loadCar ( null ); // store data of car1 in car2 car2 . printInfo (); // prints identical data as car1 } /** * Method to store a single car instance in a file using serialization * @param car */ private static void storeCar ( Car car ) { try { FileOutputStream fileOut = new FileOutputStream ( STORAGE_LOCATION ); ObjectOutputStream out = new ObjectOutputStream ( fileOut ); out . writeObject ( car ); out . flush (); out . close (); fileOut . close (); System . out . println ( \"Serialized data is saved in \" + STORAGE_LOCATION ); } catch ( IOException i ) { i . printStackTrace (); } } /** * Java is always call-by-value * See http://www.javaschubla.de/2007/javaerst0200.html * @param car * @return */ private static Car loadCar ( Car car ) { Car temp = null ; try { FileInputStream fileIn = new FileInputStream ( STORAGE_LOCATION ); ObjectInputStream in = new ObjectInputStream ( fileIn ); temp = ( Car ) in . readObject (); in . close (); fileIn . close (); } catch ( IOException i ) { i . printStackTrace (); } catch ( ClassNotFoundException c ) { System . out . println ( \"Car class not found\" ); c . printStackTrace (); } return temp ; } }","title":"Laden und Speichern von serialisierten Objekten"},{"location":"serialized_singleton/","text":"Serialisierung (Speicherung) von Singletons Die Speicherung von Singleton-Objekten ist insbesondere im Android-Umfeld sehr wichtig, da die aktuelle Activity-Instanz zerst\u00f6rt werden kann (bspw. durch Dr\u00fccken des \u2018back\u2019-Buttons) und somit die Referenz auf ein Datenmodellobjekt , welches die aktuellen Zust\u00e4nde der UI oder einer App h\u00e4lt, verloren geht bzw. bei der Neu-instanziierung ein zweites Objekt erzeugt wird und somit ungew\u00fcnschte Seiteneffekte entstehen k\u00f6nnen. Note Serialisierung von Klassen Damit Klasseninstanzen und insbesondere auch Singleton-Instanzen serialisiert werden k\u00f6nnen, muss die Klasse das Interface Serializeable implementieren. Das folgende Beispiel zeigt ein einfaches Singleton-Entwurfsmuster \u2013 in diesem Fall realisiert mittels einer privaten statischen Hilfsklasse \u2013 dessen Instanz serialisiert und damit persistiert werden kann: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package org.java.examples.singleton ; import java.io.InputStream ; import java.io.Serializable ; public class SerializedSingleton implements Serializable { private static final long serialVersionUID = - 7604766932017737115L ; private SerializedSingleton (){} private static class SingletonHelper { private static final SerializedSingleton instance = new SerializedSingleton (); } public static SerializedSingleton getInstance (){ return SingletonHelper . instance ; } /** * Useful helper method! * * Called by the readObject-method after all data is retrieved to return the correct object * see https://stackoverflow.com/questions/1168348/java-serialization-readobject-vs-readresolve * * @return the Instance to which an {@link InputStream} is linked/assigned to, ie., the object * to which an {@link InputStream} is read */ protected Object readResolve () { return getInstance (); } } Die Nutzung der Klasse wird in folgendem Anwendungscode demonstriert 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package org.java.examples.singleton ; import java.io.FileInputStream ; import java.io.FileNotFoundException ; import java.io.FileOutputStream ; import java.io.IOException ; import java.io.ObjectInput ; import java.io.ObjectInputStream ; import java.io.ObjectOutput ; import java.io.ObjectOutputStream ; public class SingletonSerializedTest { public final static String STORAGE_LOCATION = \"/Users/stefan/Google Drive/hda/LVAs/NZSE/Java/resources/singleton.ser\" ; public static void main ( String [] args ) throws FileNotFoundException , IOException , ClassNotFoundException { SerializedSingleton instanceOne = SerializedSingleton . getInstance (); // write object to file system ObjectOutput out = new ObjectOutputStream ( new FileOutputStream ( STORAGE_LOCATION )); out . writeObject ( instanceOne ); out . close (); System . out . println ( \"instanceOne hashCode=\" + instanceOne . hashCode ()); // instanceOne hashCode=1476011703 //de-serialize from file to object ObjectInput in = new ObjectInputStream ( new FileInputStream ( STORAGE_LOCATION )); SerializedSingleton instanceTwo = ( SerializedSingleton ) in . readObject (); in . close (); System . out . println ( \"instanceTwo hashCode=\" + instanceTwo . hashCode ()); // instanceTwo hashCode=1476011703 } } Die Methode protected Object readResolve() sorgt daf\u00fcr, dass das geladene Singleton-Object der aktuellen Referenz des Singletons \u00fcbergeben wird. Ohne diese Methode w\u00fcrde eine neue Instanz erzeugt werden ( erkennbar an den unterschiedlichen Objekt-Hashcodes ).","title":"Serialized Singleton"},{"location":"serialized_singleton/#serialisierung-speicherung-von-singletons","text":"Die Speicherung von Singleton-Objekten ist insbesondere im Android-Umfeld sehr wichtig, da die aktuelle Activity-Instanz zerst\u00f6rt werden kann (bspw. durch Dr\u00fccken des \u2018back\u2019-Buttons) und somit die Referenz auf ein Datenmodellobjekt , welches die aktuellen Zust\u00e4nde der UI oder einer App h\u00e4lt, verloren geht bzw. bei der Neu-instanziierung ein zweites Objekt erzeugt wird und somit ungew\u00fcnschte Seiteneffekte entstehen k\u00f6nnen. Note Serialisierung von Klassen Damit Klasseninstanzen und insbesondere auch Singleton-Instanzen serialisiert werden k\u00f6nnen, muss die Klasse das Interface Serializeable implementieren. Das folgende Beispiel zeigt ein einfaches Singleton-Entwurfsmuster \u2013 in diesem Fall realisiert mittels einer privaten statischen Hilfsklasse \u2013 dessen Instanz serialisiert und damit persistiert werden kann: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package org.java.examples.singleton ; import java.io.InputStream ; import java.io.Serializable ; public class SerializedSingleton implements Serializable { private static final long serialVersionUID = - 7604766932017737115L ; private SerializedSingleton (){} private static class SingletonHelper { private static final SerializedSingleton instance = new SerializedSingleton (); } public static SerializedSingleton getInstance (){ return SingletonHelper . instance ; } /** * Useful helper method! * * Called by the readObject-method after all data is retrieved to return the correct object * see https://stackoverflow.com/questions/1168348/java-serialization-readobject-vs-readresolve * * @return the Instance to which an {@link InputStream} is linked/assigned to, ie., the object * to which an {@link InputStream} is read */ protected Object readResolve () { return getInstance (); } } Die Nutzung der Klasse wird in folgendem Anwendungscode demonstriert 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package org.java.examples.singleton ; import java.io.FileInputStream ; import java.io.FileNotFoundException ; import java.io.FileOutputStream ; import java.io.IOException ; import java.io.ObjectInput ; import java.io.ObjectInputStream ; import java.io.ObjectOutput ; import java.io.ObjectOutputStream ; public class SingletonSerializedTest { public final static String STORAGE_LOCATION = \"/Users/stefan/Google Drive/hda/LVAs/NZSE/Java/resources/singleton.ser\" ; public static void main ( String [] args ) throws FileNotFoundException , IOException , ClassNotFoundException { SerializedSingleton instanceOne = SerializedSingleton . getInstance (); // write object to file system ObjectOutput out = new ObjectOutputStream ( new FileOutputStream ( STORAGE_LOCATION )); out . writeObject ( instanceOne ); out . close (); System . out . println ( \"instanceOne hashCode=\" + instanceOne . hashCode ()); // instanceOne hashCode=1476011703 //de-serialize from file to object ObjectInput in = new ObjectInputStream ( new FileInputStream ( STORAGE_LOCATION )); SerializedSingleton instanceTwo = ( SerializedSingleton ) in . readObject (); in . close (); System . out . println ( \"instanceTwo hashCode=\" + instanceTwo . hashCode ()); // instanceTwo hashCode=1476011703 } } Die Methode protected Object readResolve() sorgt daf\u00fcr, dass das geladene Singleton-Object der aktuellen Referenz des Singletons \u00fcbergeben wird. Ohne diese Methode w\u00fcrde eine neue Instanz erzeugt werden ( erkennbar an den unterschiedlichen Objekt-Hashcodes ).","title":"Serialisierung (Speicherung) von Singletons"},{"location":"singleton/","text":"Das Singleton-Entwurfsmuster Mit dem Singleton-Entwurfsmuster kann eine Klasse die Kontrolle f\u00fcr die Erzeugung ihrer Instanzen \u00fcbernehmen und sicherstellen, dass von ihr nur eine einzige Instanz (single) existiert. Singletons gibt es in verschiedenen Auspr\u00e4gungen (lazy-instantiation vs. ) Einfaches Singleton Achtung: Das einfache Singleton-Entwurfsmuster ist nicht Thread-safe. Es reicht aber f\u00fcr die Vorlesung und das Praktikum aus. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package org.java.examples.singleton ; /* * Singleton class contains both: a template for its instance as well as methods for creating one(!) instance */ public class SimpleSingleton { private static SimpleSingleton instance = null ; // holds the concrete instance created by the class private static int counter = 0 ; // counts the amount of instance calls private String name = \"\" ; // simple member variable that carries a given name (for demonstration) /* * Default constructor needs to be declared private so that objects can not be instantiated externally */ private SimpleSingleton () { } /* * This method needs to be public AND static so that it can be called regardless of a concrete instance */ public static SimpleSingleton getInstance () { if ( instance == null ) { instance = new SimpleSingleton (); System . out . println ( \"Object created: \" + instance . hashCode ()); } counter ++ ; System . out . println ( \"Object references returned: \" + counter + \" (hash: \" + instance . hashCode () + \")\" ) ; return instance ; } public String getName () { return name ; } public void setName ( String name ) { this . name = name ; } public static int getCounter () { return counter ; } public void print () { System . out . println ( \"My name is '\" + getName () + \"' (current refs count: \" + counter + \")\" ); } } Aufgerufen wird das Singleton wie in folgendem Beispiel dargelegt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package org.java.examples.singleton ; public class SimpleSingletonTestApp { public static void main ( String [] args ) { SimpleSingleton mySingleton = SimpleSingleton . getInstance (); mySingleton . setName ( \"Hans\" ); mySingleton . print (); SimpleSingleton mySingleton2 = SimpleSingleton . getInstance (); mySingleton2 . setName ( \"Rudi\" ); mySingleton2 . print (); // Rudi mySingleton . print (); // Rudi } } Thread-Safe Singleton Das folgende Singleton-Entwurfsmuster ist Thread-safe und nutzt hierf\u00fcr das initialization-on-demand holder idiom . Dieses Entwurfsmuster ist f\u00fcr fortgeschrittene Studierende und NICHT klausurrelevant. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package org.java.examples.singleton ; /** * Thread-safe implementation of a singleton * Does not require explicit synchronization * Uses the initialization-on-demand holder idiom that * makes uses of the class loader's own synchronisation mechanism * @author stefan zander * */ public class ThreadSafeSingleton { private ThreadSafeSingleton (){ } private static class Holder { private static final ThreadSafeSingleton INSTANCE = new ThreadSafeSingleton (); } public static ThreadSafeSingleton getInstance () { return Holder . INSTANCE ; } // Aufruf wie gehabt mit // ThreadSafeSingleton instance = ThreadSafeSingleton.getInstance() }","title":"Singleton"},{"location":"singleton/#das-singleton-entwurfsmuster","text":"Mit dem Singleton-Entwurfsmuster kann eine Klasse die Kontrolle f\u00fcr die Erzeugung ihrer Instanzen \u00fcbernehmen und sicherstellen, dass von ihr nur eine einzige Instanz (single) existiert. Singletons gibt es in verschiedenen Auspr\u00e4gungen (lazy-instantiation vs. )","title":"Das Singleton-Entwurfsmuster"},{"location":"singleton/#einfaches-singleton","text":"Achtung: Das einfache Singleton-Entwurfsmuster ist nicht Thread-safe. Es reicht aber f\u00fcr die Vorlesung und das Praktikum aus. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package org.java.examples.singleton ; /* * Singleton class contains both: a template for its instance as well as methods for creating one(!) instance */ public class SimpleSingleton { private static SimpleSingleton instance = null ; // holds the concrete instance created by the class private static int counter = 0 ; // counts the amount of instance calls private String name = \"\" ; // simple member variable that carries a given name (for demonstration) /* * Default constructor needs to be declared private so that objects can not be instantiated externally */ private SimpleSingleton () { } /* * This method needs to be public AND static so that it can be called regardless of a concrete instance */ public static SimpleSingleton getInstance () { if ( instance == null ) { instance = new SimpleSingleton (); System . out . println ( \"Object created: \" + instance . hashCode ()); } counter ++ ; System . out . println ( \"Object references returned: \" + counter + \" (hash: \" + instance . hashCode () + \")\" ) ; return instance ; } public String getName () { return name ; } public void setName ( String name ) { this . name = name ; } public static int getCounter () { return counter ; } public void print () { System . out . println ( \"My name is '\" + getName () + \"' (current refs count: \" + counter + \")\" ); } } Aufgerufen wird das Singleton wie in folgendem Beispiel dargelegt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package org.java.examples.singleton ; public class SimpleSingletonTestApp { public static void main ( String [] args ) { SimpleSingleton mySingleton = SimpleSingleton . getInstance (); mySingleton . setName ( \"Hans\" ); mySingleton . print (); SimpleSingleton mySingleton2 = SimpleSingleton . getInstance (); mySingleton2 . setName ( \"Rudi\" ); mySingleton2 . print (); // Rudi mySingleton . print (); // Rudi } }","title":"Einfaches Singleton"},{"location":"singleton/#thread-safe-singleton","text":"Das folgende Singleton-Entwurfsmuster ist Thread-safe und nutzt hierf\u00fcr das initialization-on-demand holder idiom . Dieses Entwurfsmuster ist f\u00fcr fortgeschrittene Studierende und NICHT klausurrelevant. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package org.java.examples.singleton ; /** * Thread-safe implementation of a singleton * Does not require explicit synchronization * Uses the initialization-on-demand holder idiom that * makes uses of the class loader's own synchronisation mechanism * @author stefan zander * */ public class ThreadSafeSingleton { private ThreadSafeSingleton (){ } private static class Holder { private static final ThreadSafeSingleton INSTANCE = new ThreadSafeSingleton (); } public static ThreadSafeSingleton getInstance () { return Holder . INSTANCE ; } // Aufruf wie gehabt mit // ThreadSafeSingleton instance = ThreadSafeSingleton.getInstance() }","title":"Thread-Safe Singleton"},{"location":"thread_communication/","text":"Threads and Thread Communication What are Threads and why use them ? Threads keeps to UI Thread from having to perform resource or run-time intensive operations that would slow down an app or programm. A common way to prevent this is to execute runtime intensive operations in separate runtime environments called threads . Those threads will be executed in parallel to a main thread (in particular on multi-core hardweare architectures) a How to implement Threads in Java There are two methods on how to implement Threads in Java: Using a individual class that extends Thread and overrides the run() method: 1 2 3 4 5 6 7 8 9 10 public class Main extends Thread { public void run () { System . out . println ( \"This code is running in a thread\" ); } public static void main ( String args [] ) { Main m = new Main (); m . start (); } } Using a individual class that implements the Runnable interface and implements the run() method: 1 2 3 4 5 public class Main implements Runnable { public void run () { System . out . println ( \"This code is running in a thread\" ); } } Using Threads in Android Threads can be implemented in a separate class or added to a method\u2019s body in form of an annonymous Thread object that takes an implementation of the Runnable interface in form of an annonymous inner class passed to its constructor. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public void anIndividualMethod () { new Thread ( new Runnable () { @Override public void run () { try { JSONObject obj = httpRequest . sendHttp ( \"scanChannels\" ); } catch ( IOException e ) { Log . e ( TAG , e . getMessage ()); } catch ( JSONException e ) { Log . e ( TAG , e . getMessage ()); } } }). start (); // don't forget to start the Thread obj } Thread Communication A common way for threads or AsyncTasks to communicate with the UI thread from which they were initiated is via Handler . A handler receives messages from background threads and updates views on the UI thread (Source: stackoverflow.com ) Handler encapsulate a message queue (the Looper) that allows a Thread (incl. the UI thread) to receive messages from other Threads. For processing received messages, the Thread in which the handler was instantiated has to implement the handleMessage() callback method. public void handleMessage ( Message msg ) In that way, handlers allow the realization of an asynchronous communication between different threads. Communication via Message Handlers The Thread requires a reference of the Handler instance of the receiving Thread. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public void doChannelScanAsThread ( View view ) { new Thread ( new Runnable () { @Override public void run () { try { JSONObject obj = httpRequest . sendHttp ( \"scanChannels\" ); Message msg = new Message (); Bundle bundle = new Bundle (); bundle . putString ( MainActivity . HANDLER_MESSAGE_KEY , obj . toString ()); msg . setData ( bundle ); mMessageHandler . sendMessage ( msg ); } ... Implementing the Handler The main (or receiving) Thread needs to instantiate a new message handler and pass this instance as references to the threads it wants to receive messages from. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // The Handler object used to receive Message objects from Threads (since they can't write to widgets created by main thread) private Handler mMessageHandler ; // Instantiate Handler that receives messages from Threads or AsyncTasks // see https://stackoverflow.com/questions/13840007/what-exactly-does-the-post-method-do this . mMessageHandler = new Handler ( getMainLooper ()) { @Override public void handleMessage ( Message msg ) { super . handleMessage ( msg ); if ( msg . what == MAIN_ACTIVITY_TOAST_MESSAGE_INT_KEY ) { Toast . makeText ( getApplicationContext (),( String ) msg . obj , Toast . LENGTH_SHORT ). show (); } else { txtResponse . append ( \"\\n\" + msg . getData (). getString ( HANDLER_MESSAGE_KEY )); } } }; Invoking Commands on UI Elements of the UI Thread Another possibility on how to pass data to the UI Threads is via the post() methods of its UI elements. Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public void doChannelScanAsThread ( View view ) { new Thread ( new Runnable () { @Override public void run () { try { JSONObject obj = httpRequest . sendHttp ( \"scanChannels\" ); txtResponse . post ( new Runnable () { @Override public void run () { txtResponse . setText ( obj . toString ()); } }); } catch ( IOException e ) { Log . e ( TAG , e . getMessage ()); } catch ( JSONException e ) { Log . e ( TAG , e . getMessage ()); } } }). start (); } Invoking Threads There are several ways on how to realize concurrent operations or tasks By subclassing the AsyncTask class and implementing a new AsyncTask By implementing the runnable interface and passig it to as argument to AsyncTask . execute ( new Runnable () {...} ) By creating a new class and implementing the Runnable interface By using the Thread class from the java.lang.Thread package By using classes from the java.util.concurrent package In this lecture, we only concentrate on the first three methods and specifically investigate AsyncTasks.","title":"Threads & Communication"},{"location":"thread_communication/#threads-and-thread-communication","text":"","title":"Threads and Thread Communication"},{"location":"thread_communication/#what-are-threads-and-why-use-them","text":"Threads keeps to UI Thread from having to perform resource or run-time intensive operations that would slow down an app or programm. A common way to prevent this is to execute runtime intensive operations in separate runtime environments called threads . Those threads will be executed in parallel to a main thread (in particular on multi-core hardweare architectures) a","title":"What are Threads and why use them ?"},{"location":"thread_communication/#how-to-implement-threads-in-java","text":"There are two methods on how to implement Threads in Java: Using a individual class that extends Thread and overrides the run() method: 1 2 3 4 5 6 7 8 9 10 public class Main extends Thread { public void run () { System . out . println ( \"This code is running in a thread\" ); } public static void main ( String args [] ) { Main m = new Main (); m . start (); } } Using a individual class that implements the Runnable interface and implements the run() method: 1 2 3 4 5 public class Main implements Runnable { public void run () { System . out . println ( \"This code is running in a thread\" ); } }","title":"How to implement Threads in Java"},{"location":"thread_communication/#using-threads-in-android","text":"Threads can be implemented in a separate class or added to a method\u2019s body in form of an annonymous Thread object that takes an implementation of the Runnable interface in form of an annonymous inner class passed to its constructor. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public void anIndividualMethod () { new Thread ( new Runnable () { @Override public void run () { try { JSONObject obj = httpRequest . sendHttp ( \"scanChannels\" ); } catch ( IOException e ) { Log . e ( TAG , e . getMessage ()); } catch ( JSONException e ) { Log . e ( TAG , e . getMessage ()); } } }). start (); // don't forget to start the Thread obj }","title":"Using Threads in Android"},{"location":"thread_communication/#thread-communication","text":"A common way for threads or AsyncTasks to communicate with the UI thread from which they were initiated is via Handler . A handler receives messages from background threads and updates views on the UI thread (Source: stackoverflow.com ) Handler encapsulate a message queue (the Looper) that allows a Thread (incl. the UI thread) to receive messages from other Threads. For processing received messages, the Thread in which the handler was instantiated has to implement the handleMessage() callback method. public void handleMessage ( Message msg ) In that way, handlers allow the realization of an asynchronous communication between different threads.","title":"Thread Communication"},{"location":"thread_communication/#communication-via-message-handlers","text":"The Thread requires a reference of the Handler instance of the receiving Thread. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public void doChannelScanAsThread ( View view ) { new Thread ( new Runnable () { @Override public void run () { try { JSONObject obj = httpRequest . sendHttp ( \"scanChannels\" ); Message msg = new Message (); Bundle bundle = new Bundle (); bundle . putString ( MainActivity . HANDLER_MESSAGE_KEY , obj . toString ()); msg . setData ( bundle ); mMessageHandler . sendMessage ( msg ); } ...","title":"Communication via Message Handlers"},{"location":"thread_communication/#implementing-the-handler","text":"The main (or receiving) Thread needs to instantiate a new message handler and pass this instance as references to the threads it wants to receive messages from. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // The Handler object used to receive Message objects from Threads (since they can't write to widgets created by main thread) private Handler mMessageHandler ; // Instantiate Handler that receives messages from Threads or AsyncTasks // see https://stackoverflow.com/questions/13840007/what-exactly-does-the-post-method-do this . mMessageHandler = new Handler ( getMainLooper ()) { @Override public void handleMessage ( Message msg ) { super . handleMessage ( msg ); if ( msg . what == MAIN_ACTIVITY_TOAST_MESSAGE_INT_KEY ) { Toast . makeText ( getApplicationContext (),( String ) msg . obj , Toast . LENGTH_SHORT ). show (); } else { txtResponse . append ( \"\\n\" + msg . getData (). getString ( HANDLER_MESSAGE_KEY )); } } };","title":"Implementing the Handler"},{"location":"thread_communication/#invoking-commands-on-ui-elements-of-the-ui-thread","text":"Another possibility on how to pass data to the UI Threads is via the post() methods of its UI elements. Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public void doChannelScanAsThread ( View view ) { new Thread ( new Runnable () { @Override public void run () { try { JSONObject obj = httpRequest . sendHttp ( \"scanChannels\" ); txtResponse . post ( new Runnable () { @Override public void run () { txtResponse . setText ( obj . toString ()); } }); } catch ( IOException e ) { Log . e ( TAG , e . getMessage ()); } catch ( JSONException e ) { Log . e ( TAG , e . getMessage ()); } } }). start (); }","title":"Invoking Commands on UI Elements of the UI Thread"},{"location":"thread_communication/#invoking-threads","text":"There are several ways on how to realize concurrent operations or tasks By subclassing the AsyncTask class and implementing a new AsyncTask By implementing the runnable interface and passig it to as argument to AsyncTask . execute ( new Runnable () {...} ) By creating a new class and implementing the Runnable interface By using the Thread class from the java.lang.Thread package By using classes from the java.util.concurrent package In this lecture, we only concentrate on the first three methods and specifically investigate AsyncTasks.","title":"Invoking Threads"}]}