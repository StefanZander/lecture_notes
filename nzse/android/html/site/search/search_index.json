{
    "docs": [
        {
            "location": "/actionbar/", 
            "text": "Android App Bar (aka Action Bar)\n\n\n\n\nAbstract\n\n\nLernziele\n\n\n\n\n Sie kennen die technischen Grundlagen der Android Action Bar\n\n\n Sie k\u00f6nnen eine Action Bar in ihre Applikation integrieren\n\n\n Sie verstehen wie sie Actions definieren und der Action Bar hinzuf\u00fcgen\n\n\n\n\n\n\n\n\nNote\n\n\nNote:\n The app bar should be implemented using the \nAndroid Toolbar\n to make it available for a wide range of devices. According to the Android developer guidelines, the appcompat \nToolbar\n has the best compatibility support.  \n\n\n\n\nIntroduction\n\n\nThe \napp bar\n, also known as the \naction bar\n, is one of the \nmost important design elements\n in your app's activities, because it provides a visual structure and interactive elements that are familiar to users. Using the app bar makes your app \nconsistent with other Android apps\n, allowing users to quickly understand how to operate your app and have a great experience. \n\n\nThe key functions of the app bar are as follows:\n\n\n\n\nA dedicated space for giving your app an identity and indicating the user's location in the app.\n\n\nAccess to important actions in a predictable way, such as search.\n\n\nSupport for navigation and view switching (with tabs or drop-down lists).\n\n\n\n\nThis lecture describes how to use the \nv7 appcompat\n support library's \nToolbar\n widget as an app bar. \n\n\n\n\nNote\n\n\nNote:\n There are other ways to implement an app bar\u2014for example, some themes set up an ActionBar as an app bar by default\u2014but using the \nappcompat Toolbar\n makes it easy to set up an app bar that works on the \nwidest range of devices\n, and also gives you room to customize your app bar later on as your app develops.\n\n\n\n\nChoosing the App Bar Implementation\n\n\nIn its most basic form, the action bar displays the \ntitle for the activity\n on one side and an \noverflow menu\n on the other. Even in this simple form, the app bar provides useful information to the users, and helps to give Android apps a consistent look and feel.\n\n\nAn app bar with the app title and an overflow menu\n\n\nBeginning with Android 3.0 (API level 11), all activities that use the default theme have an \nActionBar\n as an app bar. However, app bar features have gradually been added to the native \nActionBar\n over various Android releases. As a result, the \nnative \nActionBar\n behaves differently\n depending on what version of the Android system a device may be using. By contrast, the \nmost recent features are added to the support library's version of \nToolbar\n, and they are available on any device that can use the support library.\n\n\nFor this reason, it is \nrecommended to use the support library's \nToolbar\n class to implement activities' app bars\n. Using the support library's toolbar helps ensure that an app will have consistent behavior across the widest range of devices. For example, the \nToolbar\n widget provides a \nmaterial design\n experience on devices running Android 2.1 (API level 7) or later, but the native action bar doesn't support material design unless the device is running Android 5.0 (API level 21) or later.\n\n\nAdding a Toolbar to an Activity\n\n\nThese steps describe how to set up a \nToolbar\n as an activity's app bar:\n\n\nSet the necessary Support Libraries\n\n\nAdd the \nv7 appcompat\n \nsupport library\n to your project, as described in \nSupport Library Setup\n.\n\n\nIn order to use a Support Library, you must modify the \napplication's project's classpath dependencies\n within the development environment. This procedure must be performed for \neach Support Library\n that should be used.\n\n\nTo add a Support Library to your application project, include \nGoogle's Maven repository\n in your \ntop-level\n \nbuild.gradle\n file.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nallprojects\n \n{\n\n    \nrepositories\n \n{\n\n        \ngoogle\n()\n\n\n        \n// If you\nre using a version of Gradle lower than 4.1, you must\n\n        \n// instead use:\n\n        \n//\n\n        \n// maven {\n\n        \n//     url \nhttps://maven.google.com\n\n        \n// }\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nThen, add the support library to the \ndependencies\n section:\n\n\n1\n2\n3\n4\ndependencies\n \n{\n\n    \n...\n\n    \nimplementation\n \ncom.android.support:support-core-utils:27.1.1\n\n\n}\n\n\n\n\n\n\n\n\n\nWarning\n\n\nNote #1:\n The \ncompile\n command in the dependencies section is deprecated by the end of 2018. Use \nimplementation\n instead.\n\n\n\n\n\n\nWarning\n\n\nNote #2:\n Make sure that the \n:support-core-utils\n version number matches that of the \n:appcompat-v7\n version number, otherwise runtime errors might occur. \n\n\nThe following excerpt from the \nbuild.gradle (Module:app)\n file uses version \n26.1.0\n:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\ndependencies\n \n{\n\n\n    \nimplementation\n \ncom.android.support:support-core-utils:26.1.0\n\n\n    \nimplementation\n \nfileTree\n(\ndir:\n \nlibs\n,\n \ninclude:\n \n[\n*.jar\n])\n\n\n    \nimplementation\n \ncom.android.support:appcompat-v7:26.1.0\n\n\n    \nimplementation\n \ncom.android.support.constraint:constraint-layout:1.1.1\n\n    \ntestImplementation\n \njunit:junit:4.12\n\n    \nandroidTestImplementation\n \ncom.android.support.test:runner:1.0.2\n\n    \nandroidTestImplementation\n \ncom.android.support.test.espresso:espresso-core:3.0.2\n\n\n}\n\n\n\n\n\n\n\n\n\nExtend \nAppCompatActivity\n\n\nMake sure the activity class extends \nAppCompatActivity\n, as illustrated below:\n\n\n1\n2\n3\npublic\n \nclass\n \nMyActivity\n \nextends\n \nAppCompatActivity\n \n{\n\n\n// ...\n\n\n}\n\n\n\n\n\n\n\n\n\nNote\n\n\nNote:\n You need to make this change for \nevery activity\n in your app that uses a Toolbar as an app bar.\n\n\n\n\nSet the \nNoActionBar\n Theme\n\n\nIn the \napp manifest\n, set the \napplication\n element to use one of appcompat's \nNoActionBar\n themes. Using one of these themes prevents the app from using the native \nActionBar\n class to provide the app bar. For example:\n\n\n1\n2\n3\napplication\n\n    \nandroid:theme=\n@style/Theme.AppCompat.Light.NoActionBar\n\n\n/\n\n\n\n\n\n\n\nSet the Toolbar's Layout\n\n\nAdd a \nToolbar\n to the activity's layout. For example, the following layout code adds a \nToolbar\n and gives it the appearance of floating above the activity:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nandroid.support.v7.widget.Toolbar\n\n    \nandroid:id=\n@+id/my_toolbar\n\n    \nandroid:layout_width=\nmatch_parent\n\n    \nandroid:layout_height=\n?attr/actionBarSize\n\n    \nandroid:background=\n?attr/colorPrimary\n\n    \nandroid:elevation=\n4dp\n\n    \nandroid:theme=\n@style/ThemeOverlay.AppCompat.ActionBar\n\n    \napp:popupTheme=\n@style/ThemeOverlay.AppCompat.Light\n/\n\n\n\n\n\n\n\n\n\nNote\n\n\nNote:\n The Material Design specification recommends that app bars should have an \nelevation\n of \n4 dp\n.\n\n\n\n\nPosition the toolbar at the top of the activity's layout, since you are using it as an app bar.\n\n\nCall \nsetSupportActionBar()\n\n\nIn the activity's \nonCreate()\n method, call the activity's \nsetSupportActionBar()\n method, and pass the activity's toolbar. This method sets the toolbar as the app bar for the activity.\n\n\nFor example:\n\n\n1\n2\n3\n4\n5\n6\n7\n@Override\n\n\nprotected\n \nvoid\n \nonCreate\n(\nBundle\n \nsavedInstanceState\n)\n \n{\n\n    \nsuper\n.\nonCreate\n(\nsavedInstanceState\n);\n\n    \nsetContentView\n(\nR\n.\nlayout\n.\nactivity_my\n);\n\n    \nToolbar\n \nmyToolbar\n \n=\n \n(\nToolbar\n)\n \nfindViewById\n(\nR\n.\nid\n.\nmy_toolbar\n);\n\n    \nsetSupportActionBar\n(\nmyToolbar\n);\n\n\n}\n\n\n\n\n\n\n\nMake sure that you import the correct Toolbar library, as illustrated below; otherwise the \nsetSupportActionBar()\n method won't work.\n\n\n1\nimport\n \nandroid.support.v7.widget.Toolbar\n;\n\n\n\n\n\n\n\nYour app now has a basic action bar. By default, the action bar contains just the name of the app and an overflow menu. The options menu initially contains just the Settings item. \n\n\nYou can add more actions to the action bar and the overflow menu, as described in the next Section \n \nAdding and Handling Actions\n.\n\n\n\n\nNote\n\n\nHint: Use App Bar Utility Methods\n\n\nOnce you set the toolbar as an activity's app bar, you have access to the various \nutility methods\n provided by the v7 appcompat support library's \nActionBar\n class. This approach lets you do a number of useful things, like hide and show the app bar.\n\n\nTo use the \nActionBar utility methods\n, call the activity's \ngetSupportActionBar()\n method. This method returns a reference to an appcompat \nActionBar\n object. Once you have that reference, you can call any of the ActionBar methods to \nadjust the app bar\n. For example, to hide the app bar, call \nActionBar.hide()\n.\n\n\n\n\nDefining and Handling Actions\n\n\nThe app bar allows you to \nadd buttons\n for \nuser actions\n. This feature lets you put the most important actions for the current context right at the top of the app. For example, a photo browsing app might show share and create album buttons at the top when the user is looking at their photo roll; when the user looks at an individual photo, the app might show crop and filter buttons.\n\n\nSpace\n in the app bar is \nlimited\n. If an app declares \nmore actions\n than can fit in the app bar, the app bar send the excess actions to an \noverflow menu\n. The app can also specify that an action \nshould always be shown\n in the \noverflow menu\n, instead of being displayed on the app bar.\n\n\nAn app bar with a single action button and an overflow menu.\n\n\nDefining Action Buttons\n\n\nAll action buttons and other items available in the action overflow are defined in an \nXML menu resource\n (\n see \nhttps://developer.android.com/guide/topics/resources/menu-resource.html\n). \n\n\nTo \nadd actions\n to the action bar, create a \nnew XML file\n in your project's \nres/menu/\n directory.\n\n\nThe menu can be accessed (e.g. by the \nMenuInflater\n class) using \nR.menu.{name_of_your_menu_xml_file}.xml\n.\n\n\nAdd an \nitem\n element for each item you want to include in the action bar, as shown in the following code example of a menu XML file:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\nmenu\n \nxmlns:android=\nhttp://schemas.android.com/apk/res/android\n \n\n\n    \n!-- \nMark Favorite\n, should appear as action button if possible --\n\n    \nitem\n\n        \nandroid:id=\n@+id/action_favorite\n\n        \nandroid:icon=\n@drawable/ic_favorite_black_48dp\n\n        \nandroid:title=\n@string/action_favorite\n\n        \napp:showAsAction=\nifRoom\n/\n\n\n    \n!-- Settings, should always be in the overflow --\n\n    \nitem\n \nandroid:id=\n@+id/action_settings\n\n          \nandroid:title=\n@string/action_settings\n\n          \napp:showAsAction=\nnever\n/\n\n\n\n/menu\n\n\n\n\n\n\n\nThe \napp\n:\nshowAsAction\n attribute specifies whether the \naction should be shown as a button\n on the app bar.\n\n\n\n\nIf you set \napp\n:\nshowAsAction\n=\nifRoom\n (as in the example code's favorite action), the action is displayed as a \nbutton\n \nif\n there is \nroom in the app bar\n for it; if there is \nnot\n enough room, excess actions are sent to the \noverflow menu\n. \n\n\nIf you set \napp\n:\nshowAsAction\n=\nnever\n (as in the example code's settings action), the action is \nalways listed in the overflow menu\n, \nnot\n displayed in the app bar.\n\n\n\n\nThe system uses the \naction's icon\n as the action button, if the action is displayed in the app bar. \n\n\nYou can find many useful icons on the \nMaterial Icons\n page.\n\n\nSetting Actions on the Toolbar\n\n\n\n\nWarning\n\n\nAttention:\n This step is ommitted in the app bar's official google developer documents!\n\n\n\n\nActions\n should be included in the \noptions menu\n, which is part of the Toolbar if the application is developed for \nAndroid 3.0 (API level 11) and higher\n. \n\n\nBy default, the system places all items in the \naction overflow\n, which the user can reveal with the action overflow icon on the right side of the app bar (or by pressing the device Menu button, if available). To enable quick access to important actions, you can promote a few items to appear in the app bar by adding \nandroid\n:\nshowAsAction\n=\nifRoom\n to the corresponding \nitem\n elements (see Figure 3).\n\n\nThe Google Play Movies app, showing a search button and the action overflow button.\n\n\n\n\nNote\n\n\nHint:\n You can declare items for the options menu from either your Activity subclass or a Fragment subclass. If both your activity and fragment(s) declare items for the options menu, they are combined in the UI. The activity's items appear first, followed by those of each fragment in the order in which each fragment is added to the activity. If necessary, you can re-order the menu items with the \nandroid\n:\norderInCategory\n attribute in each \nitem\n you need to move.\n\n\n\n\nTo specify the options menu for an activity, override \nonCreateOptionsMenu()\n (fragments provide their own \nonCreateOptionsMenu()\n callback). In this method, you can \ninflate\n your \nmenu resource\n (defined in XML) into the Menu provided in the callback. For example:\n\n\n1\n2\n3\n4\n5\n6\n@Override\n\n\npublic\n \nboolean\n \nonCreateOptionsMenu\n(\nMenu\n \nmenu\n)\n \n{\n\n    \nMenuInflater\n \ninflater\n \n=\n \ngetMenuInflater\n();\n\n    \ninflater\n.\ninflate\n(\nR\n.\nmenu\n.\naction_items\n,\n \nmenu\n);\n\n    \nreturn\n \ntrue\n;\n\n\n}\n\n\n\n\n\n\n\nYou can also add menu items using \nadd()\n and retrieve items with \nfindItem()\n to revise their properties with MenuItem APIs.\n\n\nIf you've developed your application for \nAndroid 2.3.x and lower\n, the system calls \nonCreateOptionsMenu()\n to create the options menu when the user opens the menu for the first time.\nIf you've developed for \nAndroid 3.0 and higher\n, the system calls \nonCreateOptionsMenu()\n when \nstarting the activity\n, in order to \nshow items to the app bar\n.\n\n\nRespond to Actions\n\n\nWhen the user selects one of the app bar items, the system calls the activity's \nonOptionsItemSelected()\n callback method, and passes a \nMenuItem\n object to indicate which item was clicked. In your implementation of \nonOptionsItemSelected()\n, call the \nMenuItem.getItemId()\n method to determine which item was pressed. The \nID\n returned matches the value you declared in the corresponding \nitem\n element's \nandroid\n:\nid\n attribute.\n\n\nFor example, the following code checks to see which action the user selected. If the method does not recognize the user's action, it invokes the superclass method:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n@Override\n\n\npublic\n \nboolean\n \nonOptionsItemSelected\n(\nMenuItem\n \nitem\n)\n \n{\n\n    \nswitch\n \n(\nitem\n.\ngetItemId\n())\n \n{\n\n        \ncase\n \nR\n.\nid\n.\naction_settings\n:\n\n            \n// User chose the \nSettings\n item, show the app settings UI...\n\n            \nreturn\n \ntrue\n;\n\n\n        \ncase\n \nR\n.\nid\n.\naction_favorite\n:\n\n            \n// User chose the \nFavorite\n action, mark the current item\n\n            \n// as a favorite...\n\n            \nreturn\n \ntrue\n;\n\n\n\n        default:\n\n            \n// If we got here, the user\ns action was not recognized.\n\n            \n// Invoke the superclass to handle it.\n\n            \nreturn\n \nsuper\n.\nonOptionsItemSelected\n(\nitem\n);\n\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nAdding an Up Action\n\n\nAn app should make it easy for users to find their way back to the app's main screen. One simple way to do this is to provide an \nUp button\n on the app bar for all activities except the main one. When the user selects the Up button, the app navigates to the parent activity.\n\n\nThis section shows you how to add an Up button to an activity by declaring the activity's parent in the manifest, and enabling the app bar's Up button.\n\n\nDeclaring a Parent Activity\n\n\nTo support the \nup functionality\n in an activity, you need to declare the \nactivity's parent\n. This is done in the \napp manifest\n, by setting an \nandroid\n:\nparentActivityName\n attribute.\n\n\n\n\nNote\n\n\nNote:\n The \nandroid\n:\nparentActivityName\n attribute was introduced in Android 4.1 (API level 16). To support devices with older versions of Android, define a \nmeta-data\n name-value pair, where the name is \nandroid.support.PARENT_ACTIVITY\n and the value is the name of the parent activity.\n\n\n\n\nFor example, suppose an app has a main activity named \nMainActivity\n and a single child activity. The following manifest code declares both activities, and specifies the parent/child relationship:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\napplication\n \n...\n \n\n    ...\n\n    \n!-- The main/home activity (it has no parent activity) --\n\n\n    \nactivity\n\n        \nandroid:name=\ncom.example.myfirstapp.MainActivity\n \n...\n\n        ...\n    \n/activity\n\n\n    \n!-- A child of the main activity --\n\n    \nactivity\n\n        \nandroid:name=\ncom.example.myfirstapp.MyChildActivity\n\n        \nandroid:label=\n@string/title_activity_child\n\n        \nandroid:parentActivityName=\ncom.example.myfirstapp.MainActivity\n \n\n\n        \n!-- Parent activity meta-data to support 4.0 and lower --\n\n        \nmeta-data\n\n            \nandroid:name=\nandroid.support.PARENT_ACTIVITY\n\n            \nandroid:value=\ncom.example.myfirstapp.MainActivity\n \n/\n\n    \n/activity\n\n\n/application\n\n\n\n\n\n\n\nEnable the Up Button\n\n\nTo enable the Up button for an activity that has a parent activity, call the app bar's \nsetDisplayHomeAsUpEnabled()\n method. Typically, this would be done when the activity is created. For example, the following \nonCreate()\n method sets a Toolbar as the app bar for \nMyChildActivity\n, then enables that app bar's Up button:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n@Override\n\n\nprotected\n \nvoid\n \nonCreate\n(\nBundle\n \nsavedInstanceState\n)\n \n{\n\n    \nsuper\n.\nonCreate\n(\nsavedInstanceState\n);\n\n    \nsetContentView\n(\nR\n.\nlayout\n.\nactivity_my_child\n);\n\n\n    \n// my_child_toolbar is defined in the layout file\n\n    \nToolbar\n \nmyChildToolbar\n \n=\n\n        \n(\nToolbar\n)\n \nfindViewById\n(\nR\n.\nid\n.\nmy_child_toolbar\n);\n\n    \nsetSupportActionBar\n(\nmyChildToolbar\n);\n\n\n    \n// Get a support ActionBar corresponding to this toolbar\n\n    \nActionBar\n \nab\n \n=\n \ngetSupportActionBar\n();\n\n\n    \n// Enable the Up button\n\n    \nab\n.\nsetDisplayHomeAsUpEnabled\n(\ntrue\n);\n\n\n}\n\n\n\n\n\n\n\nThere is no need to catch the up action in the activity's \nonOptionsItemSelected()\n method. Instead, that method should call its superclass, as shown in Respond to Actions. The superclass method responds to the Up selection by navigating to the parent activity, as specified in the app manifest.\n\n\nAction Views and Action Providers\n\n\nAction Views and Action Providers are advanced topics and will not be covered in this lecture. However, more information can be found on the official android developer pages \nhttps://developer.android.com/training/appbar/action-views\n.\n\n\nDisclaimer\n\n\nMost of the information in this lecture has been compiled from the following sources:\n\n\n\n\nhttps://developer.android.com/training/appbar/\n\n\nhttps://developer.android.com/guide/topics/ui/menus\n\n\nhttp://www.vogella.com/tutorials/AndroidActionBar/article.html", 
            "title": "App Bar / Action Bar"
        }, 
        {
            "location": "/actionbar/#android-app-bar-aka-action-bar", 
            "text": "Abstract  Lernziele    Sie kennen die technischen Grundlagen der Android Action Bar   Sie k\u00f6nnen eine Action Bar in ihre Applikation integrieren   Sie verstehen wie sie Actions definieren und der Action Bar hinzuf\u00fcgen     Note  Note:  The app bar should be implemented using the  Android Toolbar  to make it available for a wide range of devices. According to the Android developer guidelines, the appcompat  Toolbar  has the best compatibility support.", 
            "title": "Android App Bar (aka Action Bar)"
        }, 
        {
            "location": "/actionbar/#introduction", 
            "text": "The  app bar , also known as the  action bar , is one of the  most important design elements  in your app's activities, because it provides a visual structure and interactive elements that are familiar to users. Using the app bar makes your app  consistent with other Android apps , allowing users to quickly understand how to operate your app and have a great experience.   The key functions of the app bar are as follows:   A dedicated space for giving your app an identity and indicating the user's location in the app.  Access to important actions in a predictable way, such as search.  Support for navigation and view switching (with tabs or drop-down lists).   This lecture describes how to use the  v7 appcompat  support library's  Toolbar  widget as an app bar.    Note  Note:  There are other ways to implement an app bar\u2014for example, some themes set up an ActionBar as an app bar by default\u2014but using the  appcompat Toolbar  makes it easy to set up an app bar that works on the  widest range of devices , and also gives you room to customize your app bar later on as your app develops.", 
            "title": "Introduction"
        }, 
        {
            "location": "/actionbar/#choosing-the-app-bar-implementation", 
            "text": "In its most basic form, the action bar displays the  title for the activity  on one side and an  overflow menu  on the other. Even in this simple form, the app bar provides useful information to the users, and helps to give Android apps a consistent look and feel.  An app bar with the app title and an overflow menu  Beginning with Android 3.0 (API level 11), all activities that use the default theme have an  ActionBar  as an app bar. However, app bar features have gradually been added to the native  ActionBar  over various Android releases. As a result, the  native  ActionBar  behaves differently  depending on what version of the Android system a device may be using. By contrast, the  most recent features are added to the support library's version of  Toolbar , and they are available on any device that can use the support library.  For this reason, it is  recommended to use the support library's  Toolbar  class to implement activities' app bars . Using the support library's toolbar helps ensure that an app will have consistent behavior across the widest range of devices. For example, the  Toolbar  widget provides a  material design  experience on devices running Android 2.1 (API level 7) or later, but the native action bar doesn't support material design unless the device is running Android 5.0 (API level 21) or later.", 
            "title": "Choosing the App Bar Implementation"
        }, 
        {
            "location": "/actionbar/#adding-a-toolbar-to-an-activity", 
            "text": "These steps describe how to set up a  Toolbar  as an activity's app bar:", 
            "title": "Adding a Toolbar to an Activity"
        }, 
        {
            "location": "/actionbar/#set-the-necessary-support-libraries", 
            "text": "Add the  v7 appcompat   support library  to your project, as described in  Support Library Setup .  In order to use a Support Library, you must modify the  application's project's classpath dependencies  within the development environment. This procedure must be performed for  each Support Library  that should be used.  To add a Support Library to your application project, include  Google's Maven repository  in your  top-level   build.gradle  file.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 allprojects   { \n     repositories   { \n         google () \n\n         // If you re using a version of Gradle lower than 4.1, you must \n         // instead use: \n         // \n         // maven { \n         //     url  https://maven.google.com \n         // } \n     }  }    Then, add the support library to the  dependencies  section:  1\n2\n3\n4 dependencies   { \n     ... \n     implementation   com.android.support:support-core-utils:27.1.1  }     Warning  Note #1:  The  compile  command in the dependencies section is deprecated by the end of 2018. Use  implementation  instead.    Warning  Note #2:  Make sure that the  :support-core-utils  version number matches that of the  :appcompat-v7  version number, otherwise runtime errors might occur.   The following excerpt from the  build.gradle (Module:app)  file uses version  26.1.0 :  1\n2\n3\n4\n5\n6\n7\n8\n9 dependencies   {       implementation   com.android.support:support-core-utils:26.1.0       implementation   fileTree ( dir:   libs ,   include:   [ *.jar ])       implementation   com.android.support:appcompat-v7:26.1.0       implementation   com.android.support.constraint:constraint-layout:1.1.1 \n     testImplementation   junit:junit:4.12 \n     androidTestImplementation   com.android.support.test:runner:1.0.2 \n     androidTestImplementation   com.android.support.test.espresso:espresso-core:3.0.2  }", 
            "title": "Set the necessary Support Libraries"
        }, 
        {
            "location": "/actionbar/#extend-appcompatactivity", 
            "text": "Make sure the activity class extends  AppCompatActivity , as illustrated below:  1\n2\n3 public   class   MyActivity   extends   AppCompatActivity   {  // ...  }     Note  Note:  You need to make this change for  every activity  in your app that uses a Toolbar as an app bar.", 
            "title": "Extend AppCompatActivity"
        }, 
        {
            "location": "/actionbar/#set-the-noactionbar-theme", 
            "text": "In the  app manifest , set the  application  element to use one of appcompat's  NoActionBar  themes. Using one of these themes prevents the app from using the native  ActionBar  class to provide the app bar. For example:  1\n2\n3 application \n     android:theme= @style/Theme.AppCompat.Light.NoActionBar  /", 
            "title": "Set the NoActionBar Theme"
        }, 
        {
            "location": "/actionbar/#set-the-toolbars-layout", 
            "text": "Add a  Toolbar  to the activity's layout. For example, the following layout code adds a  Toolbar  and gives it the appearance of floating above the activity:  1\n2\n3\n4\n5\n6\n7\n8 android.support.v7.widget.Toolbar \n     android:id= @+id/my_toolbar \n     android:layout_width= match_parent \n     android:layout_height= ?attr/actionBarSize \n     android:background= ?attr/colorPrimary \n     android:elevation= 4dp \n     android:theme= @style/ThemeOverlay.AppCompat.ActionBar \n     app:popupTheme= @style/ThemeOverlay.AppCompat.Light /     Note  Note:  The Material Design specification recommends that app bars should have an  elevation  of  4 dp .   Position the toolbar at the top of the activity's layout, since you are using it as an app bar.", 
            "title": "Set the Toolbar's Layout"
        }, 
        {
            "location": "/actionbar/#call-setsupportactionbar", 
            "text": "In the activity's  onCreate()  method, call the activity's  setSupportActionBar()  method, and pass the activity's toolbar. This method sets the toolbar as the app bar for the activity.  For example:  1\n2\n3\n4\n5\n6\n7 @Override  protected   void   onCreate ( Bundle   savedInstanceState )   { \n     super . onCreate ( savedInstanceState ); \n     setContentView ( R . layout . activity_my ); \n     Toolbar   myToolbar   =   ( Toolbar )   findViewById ( R . id . my_toolbar ); \n     setSupportActionBar ( myToolbar );  }    Make sure that you import the correct Toolbar library, as illustrated below; otherwise the  setSupportActionBar()  method won't work.  1 import   android.support.v7.widget.Toolbar ;    Your app now has a basic action bar. By default, the action bar contains just the name of the app and an overflow menu. The options menu initially contains just the Settings item.   You can add more actions to the action bar and the overflow menu, as described in the next Section    Adding and Handling Actions .   Note  Hint: Use App Bar Utility Methods  Once you set the toolbar as an activity's app bar, you have access to the various  utility methods  provided by the v7 appcompat support library's  ActionBar  class. This approach lets you do a number of useful things, like hide and show the app bar.  To use the  ActionBar utility methods , call the activity's  getSupportActionBar()  method. This method returns a reference to an appcompat  ActionBar  object. Once you have that reference, you can call any of the ActionBar methods to  adjust the app bar . For example, to hide the app bar, call  ActionBar.hide() .", 
            "title": "Call setSupportActionBar()"
        }, 
        {
            "location": "/actionbar/#defining-and-handling-actions", 
            "text": "The app bar allows you to  add buttons  for  user actions . This feature lets you put the most important actions for the current context right at the top of the app. For example, a photo browsing app might show share and create album buttons at the top when the user is looking at their photo roll; when the user looks at an individual photo, the app might show crop and filter buttons.  Space  in the app bar is  limited . If an app declares  more actions  than can fit in the app bar, the app bar send the excess actions to an  overflow menu . The app can also specify that an action  should always be shown  in the  overflow menu , instead of being displayed on the app bar.  An app bar with a single action button and an overflow menu.", 
            "title": "Defining and Handling Actions"
        }, 
        {
            "location": "/actionbar/#defining-action-buttons", 
            "text": "All action buttons and other items available in the action overflow are defined in an  XML menu resource  (  see  https://developer.android.com/guide/topics/resources/menu-resource.html ).   To  add actions  to the action bar, create a  new XML file  in your project's  res/menu/  directory.  The menu can be accessed (e.g. by the  MenuInflater  class) using  R.menu.{name_of_your_menu_xml_file}.xml .  Add an  item  element for each item you want to include in the action bar, as shown in the following code example of a menu XML file:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 menu   xmlns:android= http://schemas.android.com/apk/res/android   \n\n     !--  Mark Favorite , should appear as action button if possible -- \n     item \n         android:id= @+id/action_favorite \n         android:icon= @drawable/ic_favorite_black_48dp \n         android:title= @string/action_favorite \n         app:showAsAction= ifRoom / \n\n     !-- Settings, should always be in the overflow -- \n     item   android:id= @+id/action_settings \n           android:title= @string/action_settings \n           app:showAsAction= never /  /menu    The  app : showAsAction  attribute specifies whether the  action should be shown as a button  on the app bar.   If you set  app : showAsAction = ifRoom  (as in the example code's favorite action), the action is displayed as a  button   if  there is  room in the app bar  for it; if there is  not  enough room, excess actions are sent to the  overflow menu .   If you set  app : showAsAction = never  (as in the example code's settings action), the action is  always listed in the overflow menu ,  not  displayed in the app bar.   The system uses the  action's icon  as the action button, if the action is displayed in the app bar.   You can find many useful icons on the  Material Icons  page.", 
            "title": "Defining Action Buttons"
        }, 
        {
            "location": "/actionbar/#setting-actions-on-the-toolbar", 
            "text": "Warning  Attention:  This step is ommitted in the app bar's official google developer documents!   Actions  should be included in the  options menu , which is part of the Toolbar if the application is developed for  Android 3.0 (API level 11) and higher .   By default, the system places all items in the  action overflow , which the user can reveal with the action overflow icon on the right side of the app bar (or by pressing the device Menu button, if available). To enable quick access to important actions, you can promote a few items to appear in the app bar by adding  android : showAsAction = ifRoom  to the corresponding  item  elements (see Figure 3).  The Google Play Movies app, showing a search button and the action overflow button.   Note  Hint:  You can declare items for the options menu from either your Activity subclass or a Fragment subclass. If both your activity and fragment(s) declare items for the options menu, they are combined in the UI. The activity's items appear first, followed by those of each fragment in the order in which each fragment is added to the activity. If necessary, you can re-order the menu items with the  android : orderInCategory  attribute in each  item  you need to move.   To specify the options menu for an activity, override  onCreateOptionsMenu()  (fragments provide their own  onCreateOptionsMenu()  callback). In this method, you can  inflate  your  menu resource  (defined in XML) into the Menu provided in the callback. For example:  1\n2\n3\n4\n5\n6 @Override  public   boolean   onCreateOptionsMenu ( Menu   menu )   { \n     MenuInflater   inflater   =   getMenuInflater (); \n     inflater . inflate ( R . menu . action_items ,   menu ); \n     return   true ;  }    You can also add menu items using  add()  and retrieve items with  findItem()  to revise their properties with MenuItem APIs.  If you've developed your application for  Android 2.3.x and lower , the system calls  onCreateOptionsMenu()  to create the options menu when the user opens the menu for the first time.\nIf you've developed for  Android 3.0 and higher , the system calls  onCreateOptionsMenu()  when  starting the activity , in order to  show items to the app bar .", 
            "title": "Setting Actions on the Toolbar"
        }, 
        {
            "location": "/actionbar/#respond-to-actions", 
            "text": "When the user selects one of the app bar items, the system calls the activity's  onOptionsItemSelected()  callback method, and passes a  MenuItem  object to indicate which item was clicked. In your implementation of  onOptionsItemSelected() , call the  MenuItem.getItemId()  method to determine which item was pressed. The  ID  returned matches the value you declared in the corresponding  item  element's  android : id  attribute.  For example, the following code checks to see which action the user selected. If the method does not recognize the user's action, it invokes the superclass method:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 @Override  public   boolean   onOptionsItemSelected ( MenuItem   item )   { \n     switch   ( item . getItemId ())   { \n         case   R . id . action_settings : \n             // User chose the  Settings  item, show the app settings UI... \n             return   true ; \n\n         case   R . id . action_favorite : \n             // User chose the  Favorite  action, mark the current item \n             // as a favorite... \n             return   true ;          default: \n             // If we got here, the user s action was not recognized. \n             // Invoke the superclass to handle it. \n             return   super . onOptionsItemSelected ( item ); \n\n     }  }", 
            "title": "Respond to Actions"
        }, 
        {
            "location": "/actionbar/#adding-an-up-action", 
            "text": "An app should make it easy for users to find their way back to the app's main screen. One simple way to do this is to provide an  Up button  on the app bar for all activities except the main one. When the user selects the Up button, the app navigates to the parent activity.  This section shows you how to add an Up button to an activity by declaring the activity's parent in the manifest, and enabling the app bar's Up button.", 
            "title": "Adding an Up Action"
        }, 
        {
            "location": "/actionbar/#declaring-a-parent-activity", 
            "text": "To support the  up functionality  in an activity, you need to declare the  activity's parent . This is done in the  app manifest , by setting an  android : parentActivityName  attribute.   Note  Note:  The  android : parentActivityName  attribute was introduced in Android 4.1 (API level 16). To support devices with older versions of Android, define a  meta-data  name-value pair, where the name is  android.support.PARENT_ACTIVITY  and the value is the name of the parent activity.   For example, suppose an app has a main activity named  MainActivity  and a single child activity. The following manifest code declares both activities, and specifies the parent/child relationship:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22 application   ...   \n    ...\n\n     !-- The main/home activity (it has no parent activity) -- \n\n     activity \n         android:name= com.example.myfirstapp.MainActivity   ... \n        ...\n     /activity \n\n     !-- A child of the main activity -- \n     activity \n         android:name= com.example.myfirstapp.MyChildActivity \n         android:label= @string/title_activity_child \n         android:parentActivityName= com.example.myfirstapp.MainActivity   \n\n         !-- Parent activity meta-data to support 4.0 and lower -- \n         meta-data \n             android:name= android.support.PARENT_ACTIVITY \n             android:value= com.example.myfirstapp.MainActivity   / \n     /activity  /application", 
            "title": "Declaring a Parent Activity"
        }, 
        {
            "location": "/actionbar/#enable-the-up-button", 
            "text": "To enable the Up button for an activity that has a parent activity, call the app bar's  setDisplayHomeAsUpEnabled()  method. Typically, this would be done when the activity is created. For example, the following  onCreate()  method sets a Toolbar as the app bar for  MyChildActivity , then enables that app bar's Up button:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 @Override  protected   void   onCreate ( Bundle   savedInstanceState )   { \n     super . onCreate ( savedInstanceState ); \n     setContentView ( R . layout . activity_my_child ); \n\n     // my_child_toolbar is defined in the layout file \n     Toolbar   myChildToolbar   = \n         ( Toolbar )   findViewById ( R . id . my_child_toolbar ); \n     setSupportActionBar ( myChildToolbar ); \n\n     // Get a support ActionBar corresponding to this toolbar \n     ActionBar   ab   =   getSupportActionBar (); \n\n     // Enable the Up button \n     ab . setDisplayHomeAsUpEnabled ( true );  }    There is no need to catch the up action in the activity's  onOptionsItemSelected()  method. Instead, that method should call its superclass, as shown in Respond to Actions. The superclass method responds to the Up selection by navigating to the parent activity, as specified in the app manifest.", 
            "title": "Enable the Up Button"
        }, 
        {
            "location": "/actionbar/#action-views-and-action-providers", 
            "text": "Action Views and Action Providers are advanced topics and will not be covered in this lecture. However, more information can be found on the official android developer pages  https://developer.android.com/training/appbar/action-views .", 
            "title": "Action Views and Action Providers"
        }, 
        {
            "location": "/actionbar/#disclaimer", 
            "text": "Most of the information in this lecture has been compiled from the following sources:   https://developer.android.com/training/appbar/  https://developer.android.com/guide/topics/ui/menus  http://www.vogella.com/tutorials/AndroidActionBar/article.html", 
            "title": "Disclaimer"
        }
    ]
}