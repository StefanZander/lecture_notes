{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Foundations of JavaScript The following pages contain information about the concepts and basic building blocks of the JavaScript (JS) language. The information are collected from various sources and continuously refined, meaning, they change over time since JS is managed as a living standard with annual updates. Note Please note: The following pages only contain information of selected topics; they are no surrogates for the lecture or the standard lecture slides ( although the extend them in many occasions ). Topics General Language Concepts Reference Types and Objects Functions Closures Diese Unterlagen wurden mit MkDocs , Markdown und Visual Studio Code erstellt und mit dem individuell angepassten Material Theme for MkDocs gerendert.","title":"Index"},{"location":"#foundations-of-javascript","text":"The following pages contain information about the concepts and basic building blocks of the JavaScript (JS) language. The information are collected from various sources and continuously refined, meaning, they change over time since JS is managed as a living standard with annual updates. Note Please note: The following pages only contain information of selected topics; they are no surrogates for the lecture or the standard lecture slides ( although the extend them in many occasions ).","title":"Foundations of JavaScript"},{"location":"#topics","text":"General Language Concepts Reference Types and Objects Functions Closures Diese Unterlagen wurden mit MkDocs , Markdown und Visual Studio Code erstellt und mit dem individuell angepassten Material Theme for MkDocs gerendert.","title":"Topics"},{"location":"closures/","text":"Closures Abstract Summary Protected variables are defined in the outer scope of the function and can be accessed by exposing the inner functional scope Closures are a common way to achieve encapsulation (ie. hiding data from external and uncotrolled access) Closures consist of an outer and inner function Note Note: The app bar should be implemented using the Android Toolbar to make it available for a wide range of devices. According to the Android developer guidelines, the appcompat Toolbar has the best compatibility support. Motivation Closure == dt. Einschlie\u00dfen bzw. Abschluss What is a Closure? A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). In other words, a closure gives you access to an outer function\u2019s scope from an inner function. In JavaScript, closures are created every time a function is created, at function creation time. To use a closure, define a function inside another function and expose it. To expose a function, return it or pass it to another function. The inner function will have access to the variables in the outer function scope, even after the outer function has returned. Usage In JavaScript, closures are the primary mechanism used to enable data privacy . Data privacy is an essential property that helps in programming to an interface, not an implementation. This is an important concept in building robust software because implementation details are more likely to change in breaking ways than interface contracts. When you use closures for data privacy, the enclosed variables are only in scope within the containing (outer) function. You can\u2019t get at the data from an outside scope except through the object\u2019s privileged methods. In JavaScript, any exposed method defined within the closure scope is privileged. Einsatzzwecke Closures erlauben die Isolierung von Variablen Au\u00dferhalb einer Closure liegen alle Variablen auf dem Window-Object und das kann unvorhergesehene Konsequenzen haben, bspw. wenn externe Scripte eingebunden werden. Hier kann es passieren, dass Variablen ungewusst \u00fcberschrieben werden oder \u00e4hnliches. Transport von definierten Zust\u00e4nden ( =States ) von einem Scope in einen anderen Was wird eingeschlossen: State, also Variablen die einen zugeordneten Wert haben. Der Nutzen: Transport von State von einem Scope in einen komplett anderen Scope. Im u.g. Beispiel ist der State let obj = new MyProtectedObj ( \"James\" ) eingeschlossen in einem Closure und kann jetzt \u00fcber die Variable a \"woanders\" hin transportiert werden, d.h., an ein anderes Object (in einem anderen Scope) \u00fcbergeben werden. Also Funktion+State. Offensichtlich sehr \u00e4hnlich zu einem Objekt, welches ja ebenso Funktion+State kapselt, aber eben auch mehrere Funktionen beinhalten kann. Closures can be used to create stateful functions Closures can also be used to create stateful functions whose return values may be influenced by their internal state, e.g.: Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function MyProtectedObj ( param ) { const mySecretVariable = Math . floor ( 4711 * Math . random ()); let name = param ; return { getCode : function () { return mySecretVariable ; }, setName : function ( value ) { name = value ; }, getName : function () { return name ; } } } The closure function can be used like that 1 2 3 4 5 6 7 8 let obj = MyProtectedObj ( \"James\" ); console . log ( mySecretVariable ); // Reference Error console . log ( obj . mySecretVariable ); // outputs 'undefined' obj . getCode (); //returns the randomly generated number obj . setName ( \"John\" ); //ok obj . getName (); //outputs 'John' Pitfalls Be careful, using this does not work in closures 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function MyProtectedObj ( name ) { this . mySecretVariable = Math . floor ( 4711 * Math . random ()); this . name = name ; return { getCode : function () { return mySecretVariable ; }, setCode : function ( value ) { mySecretVariable = value ; }, getName : function () { return name ; } } } let obj = MyProtectedObj ( \"James\" ); //works since mySecretVariable is bound to the global scope console . log ( mySecretVariable ); // ... 1 2 3 4 5 6 7 8 9 10 11 12 13 var c = ( person ( name ){ this . name = name ; this . age = 0 ; return { getOlder : function () { this . age ++ ; }, printAge : function () { console . log ( age ); } } })(); Warning Please note that the returning object must not access the variables via this Disclaimer Most of the information in this lecture has been compiled from the following sources: https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36 https://www.computerbase.de/forum/threads/warum-sind-closures-so-wichtig.1906523/","title":"Closures"},{"location":"closures/#closures","text":"Abstract Summary Protected variables are defined in the outer scope of the function and can be accessed by exposing the inner functional scope Closures are a common way to achieve encapsulation (ie. hiding data from external and uncotrolled access) Closures consist of an outer and inner function Note Note: The app bar should be implemented using the Android Toolbar to make it available for a wide range of devices. According to the Android developer guidelines, the appcompat Toolbar has the best compatibility support.","title":"Closures"},{"location":"closures/#motivation","text":"Closure == dt. Einschlie\u00dfen bzw. Abschluss","title":"Motivation"},{"location":"closures/#what-is-a-closure","text":"A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). In other words, a closure gives you access to an outer function\u2019s scope from an inner function. In JavaScript, closures are created every time a function is created, at function creation time. To use a closure, define a function inside another function and expose it. To expose a function, return it or pass it to another function. The inner function will have access to the variables in the outer function scope, even after the outer function has returned.","title":"What is a Closure?"},{"location":"closures/#usage","text":"In JavaScript, closures are the primary mechanism used to enable data privacy . Data privacy is an essential property that helps in programming to an interface, not an implementation. This is an important concept in building robust software because implementation details are more likely to change in breaking ways than interface contracts. When you use closures for data privacy, the enclosed variables are only in scope within the containing (outer) function. You can\u2019t get at the data from an outside scope except through the object\u2019s privileged methods. In JavaScript, any exposed method defined within the closure scope is privileged.","title":"Usage"},{"location":"closures/#einsatzzwecke","text":"Closures erlauben die Isolierung von Variablen Au\u00dferhalb einer Closure liegen alle Variablen auf dem Window-Object und das kann unvorhergesehene Konsequenzen haben, bspw. wenn externe Scripte eingebunden werden. Hier kann es passieren, dass Variablen ungewusst \u00fcberschrieben werden oder \u00e4hnliches. Transport von definierten Zust\u00e4nden ( =States ) von einem Scope in einen anderen Was wird eingeschlossen: State, also Variablen die einen zugeordneten Wert haben. Der Nutzen: Transport von State von einem Scope in einen komplett anderen Scope. Im u.g. Beispiel ist der State let obj = new MyProtectedObj ( \"James\" ) eingeschlossen in einem Closure und kann jetzt \u00fcber die Variable a \"woanders\" hin transportiert werden, d.h., an ein anderes Object (in einem anderen Scope) \u00fcbergeben werden. Also Funktion+State. Offensichtlich sehr \u00e4hnlich zu einem Objekt, welches ja ebenso Funktion+State kapselt, aber eben auch mehrere Funktionen beinhalten kann. Closures can be used to create stateful functions Closures can also be used to create stateful functions whose return values may be influenced by their internal state, e.g.:","title":"Einsatzzwecke"},{"location":"closures/#example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function MyProtectedObj ( param ) { const mySecretVariable = Math . floor ( 4711 * Math . random ()); let name = param ; return { getCode : function () { return mySecretVariable ; }, setName : function ( value ) { name = value ; }, getName : function () { return name ; } } } The closure function can be used like that 1 2 3 4 5 6 7 8 let obj = MyProtectedObj ( \"James\" ); console . log ( mySecretVariable ); // Reference Error console . log ( obj . mySecretVariable ); // outputs 'undefined' obj . getCode (); //returns the randomly generated number obj . setName ( \"John\" ); //ok obj . getName (); //outputs 'John'","title":"Example"},{"location":"closures/#pitfalls","text":"Be careful, using this does not work in closures 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function MyProtectedObj ( name ) { this . mySecretVariable = Math . floor ( 4711 * Math . random ()); this . name = name ; return { getCode : function () { return mySecretVariable ; }, setCode : function ( value ) { mySecretVariable = value ; }, getName : function () { return name ; } } } let obj = MyProtectedObj ( \"James\" ); //works since mySecretVariable is bound to the global scope console . log ( mySecretVariable ); // ... 1 2 3 4 5 6 7 8 9 10 11 12 13 var c = ( person ( name ){ this . name = name ; this . age = 0 ; return { getOlder : function () { this . age ++ ; }, printAge : function () { console . log ( age ); } } })(); Warning Please note that the returning object must not access the variables via this","title":"Pitfalls"},{"location":"closures/#disclaimer","text":"Most of the information in this lecture has been compiled from the following sources: https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36 https://www.computerbase.de/forum/threads/warum-sind-closures-so-wichtig.1906523/","title":"Disclaimer"},{"location":"functions/","text":"Functions Abstract Summary Functions are first-class citizen, i.e., regular objects in JavaScript Functions are used for many purposes JS distinguishes between function declarations, function expressions, constructor functions and arrow functions Warning Please note: A profound understanding of functions in JavaScript is essential because JavaScript employs no concept of classes \u2013 so functions and reference types are all a programmer has to implement aggregation and inheritance. General Information Usage Overview Functions in JavaScript can be used to return values create new reference values (=instances of reference types) specify new reference types create inheritance and aggregation Functions are First-Class Objects Functions in JavaScript are first-class citizen, i.e., they inherit all properties and characteristics of normal objects: they can be assigned to variables they can be defined as methods in objects they can be passed as arguments to functions they can be returned from functions Functions are treated as full-fledged objects that exhibit the special pre-defined [[ call ]] property. The [[ call ]] property signals JS that a function object returns a pre-computed value . Function Parameters Function parameters are the names listed in the function definition. Function arguments are the real values passed to (and received by) the function. If a function is called with missing arguments (less than declared), the missing values are set to: undefined Defining Functions Function Declarations used for normal function and constructor functions to generate reference values ( =instances of reference types ) Hoisted at the top of the scope (= context ) in which they are defined Function Expression Used in/as assignment expressions, function parameters (e.g. for handlers) methods return values of functions Types of Functions in JavaScript Constructor Functions Functions invoked with new are called Constructor Fuctions . Constructor functions define reference types and return a newly created reference value. The default return type is the new reference value (instance of an reference type). The instantiation process can be manipulated by explicitly specifying the return value of a constructor function. Self-Invoking Functions Function expressions can be made \"self-invoking\". A self-invoking expression is invoked (started) automatically, without being called. Function expressions will execute automatically if the expression is followed by (). You cannot self-invoke a function declaration. You have to add parentheses around the function to indicate that it is a function expression 1 2 3 4 ( function () { let x = \"Hello World\" ; // I will invoke myself console . log ( x ); })(); The function above is actually an anonymous self-invoking function (function without name). Example #2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 <!DOCTYPE html> < html > < body > < p > Functions can be invoked automatically without being called: </ p > < p id = \"demo\" ></ p > < script > ( function () { document . getElementById ( \"demo\" ). textContent = \"Hello! I called myself\" ; })(); </ script > </ body > </ html > Alternative Notations Three more common wordings (see for more information): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Crockford's preference - parens on the inside ( function () { console . log ( 'Welcome to the Internet. Please follow me.' ); }()); //The OPs example, parentheses on the outside ( function () { console . log ( 'Welcome to the Internet. Please follow me.' ); })(); //Using the exclamation mark operator //https://stackoverflow.com/a/5654929/1175496 ! function () { console . log ( 'Welcome to the Internet. Please follow me.' ); }(); Arrow Functions Arrow functions allows a short syntax for writing function expressions. Arrow functions do not have their own this. They are not well suited for defining object methods. Arrow functions are not hoisted. They must be defined before they are used. You don't need the function keyword, the return keyword, and the curly brackets. 1 2 3 4 5 6 7 // ES5 var x = function ( x , y ) { return x * y ; } // ES6 const x = ( x , y ) => x * y ; You can only omit the return keyword and the curly brackets if the function is a single statement. Because of this, it might be a good habit to always keep them: 1 const x = ( x , y ) => { return x * y }; The 'this' Keyword in Functions In a function definition, this refers to the \"owner\" of the function. In the example above, this is the person object that \"owns\" the fullName function. In other words, this . firstName means the firstName property of this object. Disclaimer Most of the information in this lecture has been compiled from the following sources: https://www.w3schools.com/js/js_function_definition.asp","title":"Functions"},{"location":"functions/#functions","text":"Abstract Summary Functions are first-class citizen, i.e., regular objects in JavaScript Functions are used for many purposes JS distinguishes between function declarations, function expressions, constructor functions and arrow functions Warning Please note: A profound understanding of functions in JavaScript is essential because JavaScript employs no concept of classes \u2013 so functions and reference types are all a programmer has to implement aggregation and inheritance.","title":"Functions"},{"location":"functions/#general-information","text":"","title":"General Information"},{"location":"functions/#usage-overview","text":"Functions in JavaScript can be used to return values create new reference values (=instances of reference types) specify new reference types create inheritance and aggregation","title":"Usage Overview"},{"location":"functions/#functions-are-first-class-objects","text":"Functions in JavaScript are first-class citizen, i.e., they inherit all properties and characteristics of normal objects: they can be assigned to variables they can be defined as methods in objects they can be passed as arguments to functions they can be returned from functions Functions are treated as full-fledged objects that exhibit the special pre-defined [[ call ]] property. The [[ call ]] property signals JS that a function object returns a pre-computed value .","title":"Functions are First-Class Objects"},{"location":"functions/#function-parameters","text":"Function parameters are the names listed in the function definition. Function arguments are the real values passed to (and received by) the function. If a function is called with missing arguments (less than declared), the missing values are set to: undefined","title":"Function Parameters"},{"location":"functions/#defining-functions","text":"","title":"Defining Functions"},{"location":"functions/#function-declarations","text":"used for normal function and constructor functions to generate reference values ( =instances of reference types ) Hoisted at the top of the scope (= context ) in which they are defined","title":"Function Declarations"},{"location":"functions/#function-expression","text":"Used in/as assignment expressions, function parameters (e.g. for handlers) methods return values of functions","title":"Function Expression"},{"location":"functions/#types-of-functions-in-javascript","text":"","title":"Types of Functions in JavaScript"},{"location":"functions/#constructor-functions","text":"Functions invoked with new are called Constructor Fuctions . Constructor functions define reference types and return a newly created reference value. The default return type is the new reference value (instance of an reference type). The instantiation process can be manipulated by explicitly specifying the return value of a constructor function.","title":"Constructor Functions"},{"location":"functions/#self-invoking-functions","text":"Function expressions can be made \"self-invoking\". A self-invoking expression is invoked (started) automatically, without being called. Function expressions will execute automatically if the expression is followed by (). You cannot self-invoke a function declaration. You have to add parentheses around the function to indicate that it is a function expression 1 2 3 4 ( function () { let x = \"Hello World\" ; // I will invoke myself console . log ( x ); })(); The function above is actually an anonymous self-invoking function (function without name).","title":"Self-Invoking Functions"},{"location":"functions/#example-2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 <!DOCTYPE html> < html > < body > < p > Functions can be invoked automatically without being called: </ p > < p id = \"demo\" ></ p > < script > ( function () { document . getElementById ( \"demo\" ). textContent = \"Hello! I called myself\" ; })(); </ script > </ body > </ html >","title":"Example #2"},{"location":"functions/#alternative-notations","text":"Three more common wordings (see for more information): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Crockford's preference - parens on the inside ( function () { console . log ( 'Welcome to the Internet. Please follow me.' ); }()); //The OPs example, parentheses on the outside ( function () { console . log ( 'Welcome to the Internet. Please follow me.' ); })(); //Using the exclamation mark operator //https://stackoverflow.com/a/5654929/1175496 ! function () { console . log ( 'Welcome to the Internet. Please follow me.' ); }();","title":"Alternative Notations"},{"location":"functions/#arrow-functions","text":"Arrow functions allows a short syntax for writing function expressions. Arrow functions do not have their own this. They are not well suited for defining object methods. Arrow functions are not hoisted. They must be defined before they are used. You don't need the function keyword, the return keyword, and the curly brackets. 1 2 3 4 5 6 7 // ES5 var x = function ( x , y ) { return x * y ; } // ES6 const x = ( x , y ) => x * y ; You can only omit the return keyword and the curly brackets if the function is a single statement. Because of this, it might be a good habit to always keep them: 1 const x = ( x , y ) => { return x * y };","title":"Arrow Functions"},{"location":"functions/#the-this-keyword-in-functions","text":"In a function definition, this refers to the \"owner\" of the function. In the example above, this is the person object that \"owns\" the fullName function. In other words, this . firstName means the firstName property of this object.","title":"The 'this' Keyword in Functions"},{"location":"functions/#disclaimer","text":"Most of the information in this lecture has been compiled from the following sources: https://www.w3schools.com/js/js_function_definition.asp","title":"Disclaimer"},{"location":"introduction/","text":"Introduction to JavaScript Language Concepts JavaScritp (JS) is an extremely flexible language Rather than encapsulating your programm code in classes, in JS you can start coding as you go (good software engineering principles should be followed of course). JS employs no formal concept of classes Data Types Primitive Types Primitive types represent simple pieces of data; they are stored direcly in the variable object. Primitive types are treated as simple data types. JS defines 5 primitive types: Boolean true or false Number Any integer or floating-point numeric value String A character or sequence of characters delimited by either single or double quotes (JavaScript has no separate character type) Null A primitive type that has only one value, null Undefined A primitive type that has only one value, undefined (undefined is the value assigned to a variable that is not initialized) All primitive types have literal representations of their values. Note Definition: Literal Literals represent values that are not stored in a variable, such as a hard-coded name or value 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // ================================================ // Creating Primitive Types using Literal Notation // ================================================ // strings var name = \"Nicholas\" ; var selection = \"a\" ; // numbers var count = 25 ; var cost = 1.51 ; // boolean var found = true ; // null var object = null ; // undefined var flag = undefined ; var ref ; // assigned undefined automatically The typeof operator can be used to determine the type of a primitive type. It returns a string representation of that type. 1 2 3 4 5 6 7 8 // ================================================ // Identifying the Type of Primitive Types // ================================================ console . log ( typeof \"Nicholas\" ); // \"string\" console . log ( typeof 10 ); // \"number\" console . log ( typeof 5.1 ); // \"number\" console . log ( typeof true ); // \"boolean\" console . log ( typeof undefined ); // \"undefined\" Wrapper ... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // ================================================ // Primitive Type Wrappers --> allows to use Primitive Types // as if they were Reference Types (ie. Objects) // ================================================ // // Use of primitive methods var name = \"Nicholas\" ; var lowercaseName = name . toLowerCase (); // convert to lowercase var firstLetter = name . charAt ( 0 ); // get first character var middleOfName = name . substring ( 2 , 5 ); // get characters 2-4 var count = 10 ; var fixedCount = count . toFixed ( 2 ); // convert to \"10.00\" var hexCount = count . toString ( 16 ); // convert to \"a\" var flag = true ; var stringFlag = flag . toString (); // convert to \"true\" Reference Types Note Definition: Reference Type A reference type is an object that serves as boilerplate for the creation of other objects (so-called: reference values). Objects created from reference types are called instances of that reference type or reference values . Note Definition: Reference Value A reference value is an object that has been created (e.g. through a constructor function) from a reference type. A reference value is called an instance of its constructing reference type. Note Definition: Object Objects are the central elements in JS. Objects are either defined as reference types or reference values. Objects consist of an unordered number of properties inherited from their prototype and individually defined properties (so-called own properties). Concrete object data are stored as references to memory locations.","title":"Language Concepts"},{"location":"introduction/#introduction-to-javascript","text":"","title":"Introduction to JavaScript"},{"location":"introduction/#language-concepts","text":"JavaScritp (JS) is an extremely flexible language Rather than encapsulating your programm code in classes, in JS you can start coding as you go (good software engineering principles should be followed of course). JS employs no formal concept of classes","title":"Language Concepts"},{"location":"introduction/#data-types","text":"","title":"Data Types"},{"location":"introduction/#primitive-types","text":"Primitive types represent simple pieces of data; they are stored direcly in the variable object. Primitive types are treated as simple data types. JS defines 5 primitive types: Boolean true or false Number Any integer or floating-point numeric value String A character or sequence of characters delimited by either single or double quotes (JavaScript has no separate character type) Null A primitive type that has only one value, null Undefined A primitive type that has only one value, undefined (undefined is the value assigned to a variable that is not initialized) All primitive types have literal representations of their values. Note Definition: Literal Literals represent values that are not stored in a variable, such as a hard-coded name or value 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // ================================================ // Creating Primitive Types using Literal Notation // ================================================ // strings var name = \"Nicholas\" ; var selection = \"a\" ; // numbers var count = 25 ; var cost = 1.51 ; // boolean var found = true ; // null var object = null ; // undefined var flag = undefined ; var ref ; // assigned undefined automatically The typeof operator can be used to determine the type of a primitive type. It returns a string representation of that type. 1 2 3 4 5 6 7 8 // ================================================ // Identifying the Type of Primitive Types // ================================================ console . log ( typeof \"Nicholas\" ); // \"string\" console . log ( typeof 10 ); // \"number\" console . log ( typeof 5.1 ); // \"number\" console . log ( typeof true ); // \"boolean\" console . log ( typeof undefined ); // \"undefined\" Wrapper ... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // ================================================ // Primitive Type Wrappers --> allows to use Primitive Types // as if they were Reference Types (ie. Objects) // ================================================ // // Use of primitive methods var name = \"Nicholas\" ; var lowercaseName = name . toLowerCase (); // convert to lowercase var firstLetter = name . charAt ( 0 ); // get first character var middleOfName = name . substring ( 2 , 5 ); // get characters 2-4 var count = 10 ; var fixedCount = count . toFixed ( 2 ); // convert to \"10.00\" var hexCount = count . toString ( 16 ); // convert to \"a\" var flag = true ; var stringFlag = flag . toString (); // convert to \"true\"","title":"Primitive Types"},{"location":"introduction/#reference-types","text":"Note Definition: Reference Type A reference type is an object that serves as boilerplate for the creation of other objects (so-called: reference values). Objects created from reference types are called instances of that reference type or reference values . Note Definition: Reference Value A reference value is an object that has been created (e.g. through a constructor function) from a reference type. A reference value is called an instance of its constructing reference type. Note Definition: Object Objects are the central elements in JS. Objects are either defined as reference types or reference values. Objects consist of an unordered number of properties inherited from their prototype and individually defined properties (so-called own properties). Concrete object data are stored as references to memory locations.","title":"Reference Types"},{"location":"objects/","text":"Objects Abstract Summary Objects in JavaScript are dynamic; they can change at any point during code execution While OO-langueage lock-down objects based on class definitions; JS has no such restrictions Objects are central elements in JS Warning Please note: A large part of JavaScript programming is managing objects \u2013 this is why understanding how objects work is key to understanding JavaScript as a whole. Preamble Everything in JS is an object or can be accessed as objects even functions are objects Hence, a good understanding about objects is crucial for working with JS. Defining Objects Objects can be created on two ways: via an object Constructor using a constructor function via the object literal notation . The constructor function then serves as a reference type; the objects created via it are reference values (i.e., instances of a reference type). The literal notation creates only reference values. Adding Properties to Objects JS distinguishes between properties inherited from the object prototype and own properties Adding an individual property creates a new own property on that object, i.e., the object instance owns that property. Checking for the Existence of Properties Since properties can added to objects at any time, it is sometimes necessary to check for the existence of a property. The in -operator also works for methods (since methods are also properties and reference values (=objects)) Note Please note : The in operator checks for both own properties and prototype properties. If you only want the check for own properties use the hasOwnProperty () method, which is present on all objects. The hasOwnProperty () method returns true only if the given property exists and is an own property. Disclaimer Most of the information in this lecture has been compiled from the following sources: https://www.w3schools.com/js/js_function_definition.asp","title":"Objects"},{"location":"objects/#objects","text":"Abstract Summary Objects in JavaScript are dynamic; they can change at any point during code execution While OO-langueage lock-down objects based on class definitions; JS has no such restrictions Objects are central elements in JS Warning Please note: A large part of JavaScript programming is managing objects \u2013 this is why understanding how objects work is key to understanding JavaScript as a whole.","title":"Objects"},{"location":"objects/#preamble","text":"Everything in JS is an object or can be accessed as objects even functions are objects Hence, a good understanding about objects is crucial for working with JS.","title":"Preamble"},{"location":"objects/#defining-objects","text":"Objects can be created on two ways: via an object Constructor using a constructor function via the object literal notation . The constructor function then serves as a reference type; the objects created via it are reference values (i.e., instances of a reference type). The literal notation creates only reference values.","title":"Defining Objects"},{"location":"objects/#adding-properties-to-objects","text":"JS distinguishes between properties inherited from the object prototype and own properties Adding an individual property creates a new own property on that object, i.e., the object instance owns that property.","title":"Adding Properties to Objects"},{"location":"objects/#checking-for-the-existence-of-properties","text":"Since properties can added to objects at any time, it is sometimes necessary to check for the existence of a property. The in -operator also works for methods (since methods are also properties and reference values (=objects)) Note Please note : The in operator checks for both own properties and prototype properties. If you only want the check for own properties use the hasOwnProperty () method, which is present on all objects. The hasOwnProperty () method returns true only if the given property exists and is an own property.","title":"Checking for the Existence of Properties"},{"location":"objects/#disclaimer","text":"Most of the information in this lecture has been compiled from the following sources: https://www.w3schools.com/js/js_function_definition.asp","title":"Disclaimer"}]}